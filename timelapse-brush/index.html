<!DOCTYPE html>
<html lang="en">
<!--
    Timelapse Brush Simulator
    Copyright (c) 2025 Jaydz Dev
    Licensed under the MIT License
    
    This software uses gifshot (https://github.com/yahoo/gifshot)
    Copyright (c) Yahoo Inc., licensed under the MIT License
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timelapse Brush Simulator (v1.4.8)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a1d29 0%, #0f1117 100%);
            color: #e8e8e8;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            border: 2px solid #2a2d3a;
            background-color: white;
            cursor: crosshair;
            touch-action: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            margin: 10px 0;
            transition: box-shadow 0.3s ease-out, border-color 0.3s ease-out, transform 0.15s ease-in-out;
        }
        canvas.glow-pulse {
            border-color: rgba(245, 159, 190, 1);
            box-shadow: inset 0 0 60px rgba(245, 159, 190, 0.95), 
                        0 0 20px rgba(245, 159, 190, 0.6),
                        0 8px 32px rgba(0, 0, 0, 0.4);
            transform: rotate(-0.3deg);
        }
        .controls {
            margin: 8px 0;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 0 2px;
            max-width: 900px;
        }
        .controls label {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #8a8d98;
            min-width: 100px;
        }
        .controls input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(90deg, #3a3d4a 0%, #4a4d5a 100%);
            outline: none;
            cursor: pointer;
        }
        .controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #5a9ff5 0%, #4285f4 100%);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(66, 133, 244, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .controls input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 12px rgba(66, 133, 244, 0.6);
        }
        .controls input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.1);
        }
        .controls input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #5a9ff5 0%, #4285f4 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(66, 133, 244, 0.4);
        }
        /* Pink slider for fine opacity mode */
        .opacity-fine-mode::-webkit-slider-thumb {
            background: linear-gradient(135deg, #f55a9f 0%, #f442a8 100%) !important;
            box-shadow: 0 2px 8px rgba(244, 66, 168, 0.4) !important;
        }
        .opacity-fine-mode::-webkit-slider-thumb:hover {
            box-shadow: 0 3px 12px rgba(244, 66, 168, 0.6) !important;
        }
        .opacity-fine-mode::-moz-range-thumb {
            background: linear-gradient(135deg, #f55a9f 0%, #f442a8 100%) !important;
            box-shadow: 0 2px 8px rgba(244, 66, 168, 0.4) !important;
        }
        /* Slot selection modal */
        .slot-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .slot-modal-content {
            background: rgba(42, 45, 58, 0.95);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }
        .slot-modal-content h3 {
            margin: 0 0 20px 0;
            color: #e8e8e8;
            font-size: 18px;
        }
        .slot-modal-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }
        .slot-modal-buttons button {
            min-width: 60px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 600;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(60, 63, 75, 0.8);
            color: #e8e8e8;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .slot-modal-buttons button:hover {
            background: rgba(90, 159, 245, 0.3);
            border-color: rgba(90, 159, 245, 0.5);
            transform: translateY(-2px);
        }
        .slot-modal-buttons button.filled {
            background: linear-gradient(135deg, #5a9ff5 0%, #4285f4 100%);
            color: #ffffff;
            border-color: transparent;
        }
        .slot-modal-buttons button.filled:hover {
            background: linear-gradient(135deg, #6aafff 0%, #5295ff 100%);
        }
        .slot-modal-cancel {
            padding: 10px 24px;
            background: rgba(60, 63, 75, 0.8);
            color: #e8e8e8;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        .slot-modal-cancel:hover {
            background: rgba(80, 83, 95, 0.9);
        }
        .controls select {
            padding: 8px 12px;
            font-size: 13px;
            background-color: #2a2d3a;
            color: #e8e8e8;
            border: 1px solid #3a3d4a;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        }
        .controls select:hover {
            background-color: #32353f;
            border-color: #4a4d5a;
        }
        #brushType:hover {
            border-color: rgba(245, 159, 190, 1) !important;
        }
        #spacingLabel {
            transition: color 0.2s ease;
        }
        #spacingLabel:hover {
            color: #f59fbe !important;
        }
        h1 {
            font-size: 28px;
            font-weight: 700;
            margin: 20px 0 5px 0;
            background: linear-gradient(135deg, #5a9ff5 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        h3 {
            font-size: 14px;
            font-weight: 500;
            margin: 0 0 10px 0;
            color: #8a8d98;
        }
        p {
            font-size: 13px;
            color: #6a6d78;
            margin: 0 0 20px 0;
            text-align: center;
        }
        .animation-controls {
            margin: 15px 0;
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 12px 20px;
            background: rgba(42, 45, 58, 0.5);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        .frame-display {
            min-width: 100px;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: #8a8d98;
        }
        .animation-controls input[type="range"] {
            -webkit-appearance: none;
            width: 200px;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(90deg, #3a3d4a 0%, #4a4d5a 100%);
            outline: none;
        }
        .animation-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #5a9ff5 0%, #4285f4 100%);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(66, 133, 244, 0.4);
        }
        button {
            background: linear-gradient(135deg, #5a9ff5 0%, #4285f4 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(66, 133, 244, 0.3);
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(66, 133, 244, 0.4);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(66, 133, 244, 0.3);
        }
        button:disabled {
            background: linear-gradient(135deg, #3a3d4a 0%, #2a2d3a 100%);
            color: #5a5d6a;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .color-palette {
            display: flex;
            flex-direction: row;
            gap: 12px;
            max-width: 620px;
            margin: 10px 0;
            padding: 16px;
            padding-top: 28px;
            background: rgba(42, 45, 58, 0.5);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            position: relative;
            transition: box-shadow 0.2s, background 0.2s;
        }
        .palette-swatches {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 8px;
            flex: 1;
        }
        .palette-selectors {
            display: none;
        }
        .color-palette.vertical .palette-selectors {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: repeat(9, 1fr);
            gap: 4px;
            margin-right: 8px;
            margin-top: 44px;
        }
        .color-palette.vertical .palette-content {
            display: flex;
            flex-direction: row;
            align-items: start;
        }
        .palette-selector-btn {
            background: rgba(60, 63, 75, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: #9aa5b1;
            font-size: 8px;
            font-weight: 600;
            padding: 4px 2px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 24px;
        }
        .palette-selector-btn:hover {
            background: rgba(90, 159, 245, 0.3);
            border-color: rgba(90, 159, 245, 0.5);
            color: #5a9ff5;
            transform: scale(1.05);
        }
        .palette-selector-btn.active {
            background: rgba(90, 159, 245, 0.4);
            border-color: rgba(90, 159, 245, 0.7);
            color: #5a9ff5;
        }
        .palette-tools {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: stretch;
            min-width: 120px;
        }
        .palette-tools-left {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .color-palette.floating {
            position: fixed;
            z-index: 1000;
            margin: 0;
            background: rgba(42, 45, 58, 0.95);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            cursor: move;
            border: 2px solid rgba(90, 159, 245, 0.3);
        }
        .color-palette.floating:hover {
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
            border-color: rgba(90, 159, 245, 0.5);
        }
        .palette-detach-btn {
            position: absolute;
            top: 6px;
            right: 10px;
            font-size: 14px;
            background: none;
            border: none;
            color: #5a6d78;
            cursor: pointer;
            padding: 2px 6px;
            transition: color 0.2s, transform 0.2s;
            line-height: 1;
        }
        .palette-detach-btn:hover {
            color: #5a9ff5;
            transform: scale(1.2);
        }
        .palette-rotate-btn {
            position: absolute;
            top: 6px;
            right: 34px;
            font-size: 14px;
            background: none;
            border: none;
            color: #5a6d78;
            cursor: pointer;
            padding: 2px 6px;
            transition: color 0.2s, transform 0.2s;
            line-height: 1;
            display: none;
        }
        .palette-rotate-btn:hover {
            color: #5a9ff5;
            transform: rotate(90deg) scale(1.2);
        }
        .color-palette.floating .palette-rotate-btn {
            display: none;
        }
        .color-palette.vertical {
            flex-direction: column;
            max-width: 200px;
            min-height: 500px;
            padding: 28px 12px 16px 12px;
        }
        .color-palette.vertical .palette-swatches {
            grid-template-columns: repeat(2, 1fr);
            justify-content: end;
        }
        .color-palette.vertical .palette-tools {
            min-width: auto;
            width: 100%;
        }
        .color-palette.vertical .palette-name {
            writing-mode: horizontal-tb;
            text-orientation: initial;
            left: 10px;
            top: 6px;
            transform: none;
            font-size: 7px;
        }
        .color-palette.vertical .palette-rotate-btn {
            display: block;
            left: 10px;
            right: auto;
            top: 30px;
        }
        .color-palette.vertical .palette-detach-btn {
            display: none;
        }
        .palette-name {
            position: absolute;
            top: 6px;
            left: 10px;
            font-size: 9px;
            font-weight: 600;
            color: #798b96;
            cursor: pointer;
            transition: all 0.05s ease-in;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            pointer-events: auto;
        }
        .color-palette:hover .palette-name {
            color: #5a9ff5;
            text-shadow: 0 0 8px rgba(90, 159, 245, 0.6);
            letter-spacing: 1px;
            transform: scale(1.05);
            transition: all 0.6s ease-out;
        }
        .palette-name:hover {
            color: #f59fbe !important;
            text-shadow: 0 0 8px rgba(245, 159, 190, 0.6) !important;
        }
        .color-swatch {
            width: 30px;
            height: 30px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .color-swatch:hover {
            transform: scale(1.15);
            border-color: rgba(90, 159, 245, 0.5);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        .color-swatch.selected {
            border: 3px solid #5a9ff5;
            box-shadow: 0 0 0 2px rgba(90, 159, 245, 0.3), 0 4px 12px rgba(90, 159, 245, 0.4);
            transform: scale(1.05);
        }
        
        /* Brush Controls Box */
        #brushControlsContainer {
            display: flex;
            justify-content: center;
            width: 100%;
        }
        .brush-controls {
            position: relative;
            background: linear-gradient(135deg, #2a2d3a 0%, #3a3d4a 100%);
            border: 1px solid #4a4d5a;
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            max-width: 680px;
            width: 100%;
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }
        .brush-controls .controls label {
            min-width: 100px;
        }
        .brush-controls input[type="range"] {
            width: 120px;
        }
        .brush-controls.floating {
            position: fixed;
            z-index: 1000;
            cursor: move;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        }
        .controls-title {
            position: absolute;
            top: 6px;
            left: 10px;
            font-size: 10px;
            font-weight: 600;
            color: #798b96;
            cursor: pointer;
            transition: all 0.05s ease-in;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            pointer-events: auto;
        }
        .brush-controls:hover .controls-title {
            color: #5a9ff5;
            text-shadow: 0 0 8px rgba(90, 159, 245, 0.6);
            letter-spacing: 1px;
            transform: scale(1.05);
            transition: all 0.6s ease-out;
        }
        .controls-title:hover {
            color: #f59fbe !important;
            text-shadow: 0 0 8px rgba(245, 159, 190, 0.6) !important;
        }
        .controls-rotate-btn,
        .controls-detach-btn {
            position: absolute;
            top: 6px;
            background: transparent;
            border: none;
            font-size: 14px;
            cursor: pointer;
            padding: 4px;
            transition: transform 0.2s;
            z-index: 10;
        }
        .controls-rotate-btn {
            right: 34px;
            display: none;
        }
        .controls-detach-btn {
            right: 10px;
        }
        .controls-rotate-btn:hover,
        .controls-detach-btn:hover {
            transform: scale(1.2);
        }
        .brush-controls.floating .controls-rotate-btn {
            display: none;
        }
        .brush-controls .controls {
            margin: 8px 0;
        }
        .controls-wrapper {
            flex: 1;
        }
        
        /* Vertical layout for brush controls */
        .brush-controls.vertical {
            flex-direction: column;
            max-width: 180px;
            min-height: 500px;
            padding: 30px 10px 16px 10px;
        }
        .brush-controls.vertical .controls-wrapper {
            flex: none;
            width: 100%;
        }
        .brush-controls.vertical .controls {
            flex-direction: column;
            gap: 12px;
            align-items: flex-start;
        }
        .brush-controls.vertical .controls label {
            min-width: auto;
            width: 100%;
        }
        .brush-controls.vertical input[type="range"] {
            width: 100%;
        }
        .brush-controls.vertical .controls-title {
            writing-mode: horizontal-tb;
            text-orientation: initial;
            left: 10px;
            top: 6px;
            transform: none;
        }
        .brush-controls.vertical .controls-rotate-btn {
            display: block;
            right: 10px;
            left: auto;
            top: 30px;
        }
        .brush-controls.vertical .controls-detach-btn {
            display: none;
        }
        
        /* Rotation mode buttons */
        .rotation-mode-btn {
            padding: 4px 8px;
            font-size: 10px;
            background: rgba(60,63,75,0.6);
            color: #9aa5b1;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .rotation-mode-btn:hover {
            background: rgba(90, 159, 245, 0.3);
            border-color: rgba(90, 159, 245, 0.5);
            color: #5a9ff5;
        }
        .rotation-mode-btn.active {
            background: rgba(90, 159, 245, 0.5) !important;
            border-color: rgba(90, 159, 245, 0.8) !important;
            color: #ffffff !important;
        }
        .rotation-modes {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-self: stretch;
            margin-top: 24px;
            min-width: 70px;
        }
        .brush-controls.vertical .rotation-modes {
            flex-direction: row;
            margin-top: 2px;
            justify-content: center;
            min-width: auto;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
</head>
<body>
    <h1>Timelapse Brush Simulator (v1.4.8)</h1>
    <h3>By <a href="../index.html" style="color: #cd4ab7; text-decoration: none; transition: color 0.2s;">Jaydz Dev</a> [ <em>development time - 15 days</em> ]</h3>
    <p>Draw with customizable brushes, create dual effects, and animate frames with onion skinning.</br><span style="color: #89a3c2;">A tech demo</span> using Canvas 2D API, advanced brush dynamics, and gifshot generation.</br>There is a lot to unpack here, please see the documentation below or <span id="introPinIcon" style="color: #89a3c2; cursor: pointer;">click (üìå) to change layout.</span></p>
    
    <!-- Timelapse Challenge Controls -->
    <div id="buttonRow" style="margin: 4px 0; display: flex; gap: 8px; align-items: center;">
        <button id="export" style="font-size: 16px; padding: 10px 20px;">Save PNG</button>
        <button id="loadCanvas" style="font-size: 16px; padding: 10px 20px;">Load PNG</button>
        <input type="file" id="canvasFileInput" accept=".png,.jpg,.jpeg" style="display: none;">
        <button id="clearCanvas" style="font-size: 16px; padding: 10px 20px;">Clear</button>
        <button id="startTimelapse" style="font-size: 16px; padding: 10px 20px;">üé® Start Timelapse Challenge</button>
    </div>
    
    <!-- Timelapse Challenge Display -->
    <div id="timelapseChallenge" style="display: none; background: linear-gradient(135deg, rgba(255, 193, 7, 0.15) 0%, rgba(255, 152, 0, 0.15) 100%); border: 2px solid rgba(255, 193, 7, 0.5); padding: 16px 24px; border-radius: 12px; margin: 15px 0; font-weight: 600; font-size: 16px; backdrop-filter: blur(10px); box-shadow: 0 4px 16px rgba(255, 193, 7, 0.2);">
        üé® Strokes Remaining: <span id="strokeCount" style="color: #ffc107; font-size: 20px; font-weight: 700;">30</span> | <button id="exportTimelapse" disabled>Export Timelapse</button>
    </div>

    <!-- Color Palette -->
    <div style="display: flex; align-items: flex-start; gap: 12px; margin: 0 0 0 0;" id="paletteContainer">
        <div class="color-palette" id="colorPalette">
            <button class="palette-rotate-btn" id="paletteRotateBtn" title="Rotate Palette">üîÑ</button>
            <button class="palette-detach-btn" id="paletteDetachBtn" title="Detach/Dock Palette">üìå</button>
            <div class="palette-content">
                <div class="palette-selectors" id="paletteSelectors">
                    <button class="palette-selector-btn active" data-palette="0">P1</button>
                    <button class="palette-selector-btn" data-palette="1">P2</button>
                    <button class="palette-selector-btn" data-palette="2">P3</button>
                    <button class="palette-selector-btn" data-palette="3">P4</button>
                    <button class="palette-selector-btn" data-palette="4">P5</button>
                    <button class="palette-selector-btn" data-palette="5">P6</button>
                    <button class="palette-selector-btn" data-palette="6">P7</button>
                    <button class="palette-selector-btn" data-palette="7">P8</button>
                    <button class="palette-selector-btn" data-palette="8">P9</button>
                </div>
                <div class="palette-swatches" id="paletteSwatches"></div>
            </div>
            <div class="palette-tools">
                <select id="brushType" style="padding: 6px 10px 6px 12px; font-size: 11px; background: rgba(60,63,75,0.8); color: #e0e0e0; border: 2px solid rgba(245, 159, 190, 0.6); border-radius: 3px; cursor: pointer; width: 100%;">
                    <option value="round">Round (r)</option>
                    <option value="square">Square (s)</option>
                    <option value="oil">Oil (o)</option>
                    <option value="daub">Daub (d)</option>
                    <option value="render">Render (e)</option>
                    <option value="pixel">Pixel (p)</option>
                    <option value="fill">Fill (f)</option>
                    <option value="texture" selected>Texture (t)</option>
                </select>
                <button id="loadTexture" style="padding: 2px 12px; font-size: 11px; white-space: nowrap; width: 100%; display: none;">üñºÔ∏è Load Stamp</button>
                <input type="file" id="textureFileInput" accept=".png,.jpg,.jpeg" style="display: none;">
                <button id="eyedropper" style="padding: 2px 12px; font-size: 11px; white-space: nowrap; width: 100%;">üé® Eyedropper</button>
                <div style="display: flex; gap: 4px;">
                    <button id="renderBtn" style="padding: 2px 8px; font-size: 11px; white-space: nowrap; flex: 1;">‚ú® Render</button>
                    <button id="paletteUndoBtn" style="padding: 2px 8px; font-size: 11px; white-space: nowrap; flex: 1;">‚Ü∂ Undo</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Canvas -->
    <canvas id="canvas" width="800" height="450"></canvas>

    <!-- Brush Controls -->
    <div id="brushControlsContainer">
        <div class="brush-controls" id="brushControls">
            <div class="controls-title" id="controlsTitle" style="cursor: pointer;" title="Click to view all keyboard shortcuts">Brush Control for Square (s)</div>
            <button class="controls-rotate-btn" id="controlsRotateBtn" title="Rotate layout">üîÑ</button>
            <button class="controls-detach-btn" id="controlsDetachBtn" title="Undock controls">üìå</button>
            
            <div class="controls-wrapper">
                <div class="controls">
                    <label>Size: <input type="range" id="brushSize" min="1" max="100" value="30"> <span id="brushSizeValue" style="color: #5a9ff5; font-weight: 600; min-width: 35px; display: inline-block;">30</span></label>
                    <label>Opacity: <input type="range" id="brushOpacity" min="0.1" max="1" step="0.1" value="0.2"> <span id="brushOpacityValue" style="color: #5a9ff5; font-weight: 600; min-width: 35px; display: inline-block;">0.2</span></label>
                    <label>Hardness: <input type="range" id="brushHardness" min="0" max="1" step="0.1" value="0.5"> <span id="brushHardnessValue" style="color: #5a9ff5; font-weight: 600; min-width: 35px; display: inline-block;">0.5</span></label>
                    <label><span id="spacingLabel" style="cursor: pointer; text-decoration: underline;" title="Click to toggle spacing mode">Spacing (Smooth):</span> <input type="range" id="brushSpacing" min="0.1" max="5" step="0.1" value="1"> <span id="brushSpacingValue" style="color: #5a9ff5; font-weight: 600; min-width: 35px; display: inline-block;">1.0</span></label>
                </div>
                <div class="controls">
                    <label>Flow: <input type="range" id="brushFlow" min="0.1" max="1" step="0.1" value="1"> <span id="brushFlowValue" style="color: #5a9ff5; font-weight: 600; min-width: 35px; display: inline-block;">1.0</span></label>
                    <label>Scatter: <input type="range" id="brushScatter" min="0" max="100" value="0"> <span id="brushScatterValue" style="color: #5a9ff5; font-weight: 600; min-width: 35px; display: inline-block;">0</span></label>
                    <label>Taper: <input type="range" id="brushTaper" min="0" max="1" step="0.1" value="0"> <span id="brushTaperValue" style="color: #5a9ff5; font-weight: 600; min-width: 35px; display: inline-block;">0.0</span></label>
                    <label>Jitter: <input type="range" id="brushJitter" min="0" max="1" step="0.1" value="0"> <span id="brushJitterValue" style="color: #5a9ff5; font-weight: 600; min-width: 35px; display: inline-block;">0.0</span></label>
                </div>
            </div>
            <div class="rotation-modes" id="rotationModes">
                <button class="rotation-mode-btn active" data-mode="none" title="No rotation (default)">Fixed</button>
                <button class="rotation-mode-btn" data-mode="follow" title="Rotate to follow stroke direction">Follow</button>
                <button class="rotation-mode-btn" data-mode="random" title="Random rotation per stamp">Random</button>
                <button class="rotation-mode-btn" data-mode="spin" title="Continuously spin along stroke">Spin</button>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="exportBrush">üíæ Export Brush</button>
        <button id="importBrush">üìÇ Import Brush</button>
        <button class="brush-slot" id="brushSlot1" data-slot="1" style="min-width: 40px; padding: 6px 12px;">1</button>
        <button class="brush-slot" id="brushSlot2" data-slot="2" style="min-width: 40px; padding: 6px 12px;">2</button>
        <button class="brush-slot" id="brushSlot3" data-slot="3" style="min-width: 40px; padding: 6px 12px;">3</button>
        <button class="brush-slot" id="brushSlot4" data-slot="4" style="min-width: 40px; padding: 6px 12px;">4</button>
        <button class="brush-slot" id="brushSlot5" data-slot="5" style="min-width: 40px; padding: 6px 12px;">5</button>
        <input type="file" id="brushFileInput" accept=".jbrush" style="display: none;">
    </div>
    
    <div class="controls">
        <button id="enableDual" style="background: linear-gradient(135deg, #000000 0%, #000000 100%); color: #ffffff; border: none;">Enable Dual Brush</button>
        <button id="toggleStabilisation" style="background: linear-gradient(135deg, #000000 0%, #000000 100%); color: #ffffff; border: none;">üéØ Enable Stabilisation</button>
        <button id="toggleStampMode" style="background: linear-gradient(135deg, #000000 0%, #000000 100%); color: #ffffff; border: none;">üñåÔ∏è Stamp Creator</button>
        <label style="display: none;" id="stabilisationStrengthLabel">Stabilisation: <input type="range" id="stabilisationStrength" min="0" max="100" value="80"> 
          <span id="stabilisationStrengthValue" style="color: #5a9ff5; font-weight: 600; min-width: 35px; display: inline-block;">80%</span>
        </label>
    </div>

    <!-- Slot Selection Modal -->
    <div id="slotModal" class="slot-modal">
        <div class="slot-modal-content">
            <h3>Select a slot to import brush:</h3>
            <div class="slot-modal-buttons">
                <button class="slot-select-btn" data-slot="1">Slot 1<br><small>(Empty)</small></button>
                <button class="slot-select-btn" data-slot="2">Slot 2<br><small>(Empty)</small></button>
                <button class="slot-select-btn" data-slot="3">Slot 3<br><small>(Empty)</small></button>
                <button class="slot-select-btn" data-slot="4">Slot 4<br><small>(Empty)</small></button>
                <button class="slot-select-btn" data-slot="5">Slot 5<br><small>(Empty)</small></button>
            </div>
            <button class="slot-modal-cancel" id="slotModalCancel">Cancel</button>
        </div>
    </div>

    <!-- Secondary Color Selection Modal -->
    <div id="secondaryColorModal" class="slot-modal">
        <div class="slot-modal-content">
            <h3>Select Secondary Color</h3>
            <p style="margin: 10px 0 20px 0; font-size: 14px; color: #8a8d98;">Choose a color from the current palette for subtle mixing with your brush strokes:</p>
            <div id="secondaryColorSwatches" class="palette-swatches" style="grid-template-columns: repeat(5, 1fr); gap: 8px; margin-bottom: 20px;"></div>
            <button class="slot-modal-cancel" id="secondaryColorCancel">Cancel</button>
        </div>
    </div>

    <!-- Animation Controls -->
    <div class="animation-controls">
        <button id="addFrame">Add Frame</button>
        <button id="playAnimation">Play</button>
        <button id="toggleOnion">Toggle Onion Skin</button>
        <button id="exportGif">Export GIF</button>
        <span class="frame-display">Frame: <span id="currentFrame">1</span> / <span id="totalFrames">1</span></span>
        <input type="range" id="frameSlider" min="1" max="1" value="1" style="width: 200px;">
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        ctx.imageSmoothingEnabled = true; // Smooth rendering

        // Helper function to create a white frame
        function createWhiteFrame() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            // Fill with white (RGB: 255, 255, 255, Alpha: 255)
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255;     // Red
                data[i + 1] = 255; // Green
                data[i + 2] = 255; // Blue
                data[i + 3] = 255; // Alpha
            }
            return imageData;
        }

        // Animation state
        let frames = [createWhiteFrame()]; // Start with white frame
        let currentFrameIndex = 0;
        let isPlaying = false;
        let onionSkin = true;
        let animationInterval;

        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let strokeProgress = 0; // Track position in stroke for taper
        let strokeLength = 0; // Total stroke length for taper calculation
        let dualBrushEnabled = false;
        let spacingSpeedMode = false; // Toggle between distance-based and speed-based spacing
        let accumulatedDistance = 0; // Track distance for fixed spacing mode
        let rotationMode = 'none'; // Rotation modes: none, follow, random, spin
        let spinAngle = 0; // Track angle for spin mode
        let primaryBrush = { type: 'round', size: 10, opacity: 1, hardness: 0.5, color: '#8d9855', spacing: 1, flow: 1, scatter: 0, taper: 0, jitter: 0 };
        let secondaryBrush = { type: 'texture', size: 8, opacity: 0.5, hardness: 0.3, color: '#ffffff', spacing: 1, flow: 1, scatter: 5, taper: 0, jitter: 0 };

        // Track time for speed-based taper
        let lastMoveTime = null;

        // Texture brush state
        let brushTexture = null; // HTMLImageElement for custom texture
        let defaultTexture = null; // Default grayscale texture
        let textureLoaded = false; // Flag to track if texture is ready

        // Timelapse challenge state
        let timelapseMode = false;
        let strokesRemaining = 30;
        let timelapseSnapshots = [];
        let drawingBlocked = false;

        // Eyedropper state
        let eyedropperMode = false;
        let previousBrushType = 'texture'; // Store brush type before eyedropper
        
        // Stabilisation system
        let stabilisationEnabled = false;
        let stabilisationStrength = 0.8; // 0-1 range - increased for stronger curve correction
        let strokePoints = []; // Buffer for stabilisation
        
        // Palette drag state
        let paletteFloating = false;
        let paletteDragging = false;
        let paletteDragOffsetX = 0;
        let paletteDragOffsetY = 0;
        let paletteOriginalParent = null;

        // Brush controls floating state
        let controlsFloating = false;
        let controlsDragging = false;
        let controlsDragOffsetX = 0;
        let controlsDragOffsetY = 0;
        let controlsOriginalParent = null;

        // Pixel art mode state
        let pixelArtMode = false;
        let pixelArtWidth = 100; // Target pixel art width
        let pixelArtHeight = 56; // Target pixel art height (maintaining 16:9)
        let originalWidth = 800;
        let originalHeight = 450;
        let pixelScale = 1; // Scale factor for display

        // Stamp creation mode state
        let stampMode = false;
        let stampWidth = 512;
        let stampHeight = 512;
        let originalPalette = null; // Store original palette for restoration
        let grayscalePalette = [
            '#000000', '#0d0d0d', '#1a1a1a', '#272727', '#343434',
            '#414141', '#4e4e4e', '#5b5b5b', '#686868', '#757575',
            '#828282', '#8f8f8f', '#9c9c9c', '#a9a9a9', '#b6b6b6',
            '#c3c3c3', '#d0d0d0', '#dddddd', '#eaeaea', '#ffffff'
        ];

        // Undo/Redo state
        let undoStack = []; // History of previous states
        let redoStack = []; // History of undone states
        const maxUndoStates = 20; // Limit undo history to 20 states

        // Opacity scale mode
        let opacityFineMode = false; // Toggle between 0.1-1.0 and 0-0.1 scales

        // Brush slots state
        let brushSlots = [{}, {}, {}, {}, {}]; // 5 empty slots
        let selectedSlot = null; // Currently selected slot for import

        // Load default texture from grunge-08.png
        function loadDefaultTexture() {
            const img = new Image();
            img.crossOrigin = 'anonymous'; // Prevent CORS taint
            img.onload = function() {
                // Convert black pixels to transparent in default texture
                const processCanvas = document.createElement('canvas');
                processCanvas.width = img.width;
                processCanvas.height = img.height;
                const processCtx = processCanvas.getContext('2d');
                processCtx.drawImage(img, 0, 0);
                
                let imageData;
                try {
                    imageData = processCtx.getImageData(0, 0, img.width, img.height);
                } catch (e) {
                    console.error('Canvas tainted, using image directly without processing:', e);
                    defaultTexture = img;
                    brushTexture = img;
                    textureLoaded = true;
                    return;
                }
                
                const data = imageData.data;
                
                // Convert black (and near-black) pixels to transparent
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // If pixel is black or very dark (threshold: < 10 for each channel)
                    if (r < 10 && g < 10 && b < 10) {
                        data[i + 3] = 0; // Set alpha to 0 (transparent)
                    }
                }
                
                processCtx.putImageData(imageData, 0, 0);
                
                // Create new image from processed canvas
                const processedImg = new Image();
                processedImg.onload = () => {
                    defaultTexture = processedImg;
                    brushTexture = processedImg;
                    textureLoaded = true;
                    console.log(`‚úÖ Default texture loaded and processed: grunge-06.png (${img.width}√ó${img.height})`);
                    console.log(`   Black pixels converted to transparent. Texture ready for use.`);
                    console.log(`   brushTexture dimensions: ${processedImg.width}√ó${processedImg.height}`);
                };
                processedImg.onerror = () => {
                    console.error('‚ùå Failed to process default texture');
                };
                processedImg.src = processCanvas.toDataURL();
            };
            img.onerror = function() {
                console.warn('Failed to load default texture from file:// protocol. Please use HTTP server (e.g., http://localhost:8080)');
                console.log('Creating fallback texture...');
                // Fallback: create noise pattern
                const size = 128;
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                const imageData = ctx.createImageData(size, size);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const value = Math.floor(Math.random() * 256);
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                    data[i + 3] = 255;
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                const fallbackImg = new Image();
                fallbackImg.onload = () => {
                    defaultTexture = fallbackImg;
                    brushTexture = fallbackImg;
                    textureLoaded = true;
                    console.log('Fallback texture ready');
                };
                fallbackImg.src = canvas.toDataURL();
            };
            img.src = 'brushes/grunge-06.png';
        }
        
        // Initialize default texture
        loadDefaultTexture();

        // Cursor generation
        function updateCursor() {
            if (eyedropperMode) {
                canvas.style.cursor = 'crosshair';
                return;
            }

            const brushType = document.getElementById('brushType').value;
            const brushSize = parseInt(document.getElementById('brushSize').value);
            
            // Limit cursor size for performance
            const cursorSize = Math.min(brushSize, 64);
            const halfSize = cursorSize / 2;
            
            // Create a canvas for the cursor
            const cursorCanvas = document.createElement('canvas');
            cursorCanvas.width = cursorSize + 2;
            cursorCanvas.height = cursorSize + 2;
            const cursorCtx = cursorCanvas.getContext('2d');
            
            const centerX = (cursorSize + 2) / 2;
            const centerY = (cursorSize + 2) / 2;
            
            // Draw cursor based on brush type
            cursorCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            cursorCtx.lineWidth = 1;
            
            if (brushType === 'round' || brushType === 'daub' || brushType === 'render') {
                // Circle cursor
                cursorCtx.beginPath();
                cursorCtx.arc(centerX, centerY, halfSize, 0, 2 * Math.PI);
                cursorCtx.stroke();
                
                // Inner white circle for visibility
                cursorCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                cursorCtx.lineWidth = 1;
                cursorCtx.beginPath();
                cursorCtx.arc(centerX, centerY, halfSize - 1, 0, 2 * Math.PI);
                cursorCtx.stroke();
            } else if (brushType === 'oil') {
                // Rectangle cursor (2:1 ratio)
                const rectWidth = cursorSize;
                const rectHeight = cursorSize * 0.5;
                const rectX = centerX - rectWidth / 2;
                const rectY = centerY - rectHeight / 2;
                
                cursorCtx.strokeRect(rectX, rectY, rectWidth, rectHeight);
                
                // Inner white rectangle
                cursorCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                cursorCtx.strokeRect(rectX + 1, rectY + 1, rectWidth - 2, rectHeight - 2);
            } else if (brushType === 'square') {
                // Square cursor
                cursorCtx.strokeRect(1, 1, cursorSize, cursorSize);
                
                // Inner white square
                cursorCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                cursorCtx.strokeRect(2, 2, cursorSize - 2, cursorSize - 2);
            } else if (brushType === 'texture') {
                // Circle with texture pattern indicator
                cursorCtx.beginPath();
                cursorCtx.arc(centerX, centerY, halfSize, 0, 2 * Math.PI);
                cursorCtx.stroke();
                
                // Inner white circle
                cursorCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                cursorCtx.lineWidth = 1;
                cursorCtx.beginPath();
                cursorCtx.arc(centerX, centerY, halfSize - 1, 0, 2 * Math.PI);
                cursorCtx.stroke();
                
                // Add texture hash pattern in center
                cursorCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                cursorCtx.lineWidth = 1;
                const hashSize = halfSize * 0.6;
                for (let i = -1; i <= 1; i++) {
                    cursorCtx.beginPath();
                    cursorCtx.moveTo(centerX - hashSize, centerY + i * (hashSize / 2));
                    cursorCtx.lineTo(centerX + hashSize, centerY + i * (hashSize / 2));
                    cursorCtx.stroke();
                }
            } else if (brushType === 'pixel') {
                // Pixel brush cursor - small square
                const pixelSize = Math.max(4, cursorSize); // At least 4px visible
                cursorCanvas.width = pixelSize + 2;
                cursorCanvas.height = pixelSize + 2;
                const pxCtx = cursorCanvas.getContext('2d');
                
                // Draw pixel square
                pxCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                pxCtx.lineWidth = 1;
                pxCtx.strokeRect(1, 1, pixelSize, pixelSize);
                
                // Inner white square
                pxCtx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                pxCtx.strokeRect(2, 2, pixelSize - 2, pixelSize - 2);
                
                // Center dot
                pxCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                pxCtx.fillRect((pixelSize + 2) / 2 - 1, (pixelSize + 2) / 2 - 1, 2, 2);
                
                const pxUrl = pxCtx.canvas.toDataURL();
                canvas.style.cursor = `url(${pxUrl}) ${(pixelSize + 2) / 2} ${(pixelSize + 2) / 2}, crosshair`;
                return;
            } else if (brushType === 'fill') {
                // Paint bucket icon (simple representation)
                canvas.style.cursor = 'crosshair';
                return;
            }
            
            // Add center crosshair
            cursorCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            cursorCtx.lineWidth = 1;
            cursorCtx.beginPath();
            cursorCtx.moveTo(centerX - 3, centerY);
            cursorCtx.lineTo(centerX + 3, centerY);
            cursorCtx.moveTo(centerX, centerY - 3);
            cursorCtx.lineTo(centerX, centerY + 3);
            cursorCtx.stroke();
            
            // Convert to data URL and set as cursor
            const cursorUrl = cursorCanvas.toDataURL();
            canvas.style.cursor = `url(${cursorUrl}) ${centerX} ${centerY}, crosshair`;
        }

        // Undo/Redo functions
        function saveState() {
            try {
                // Clone all frames with proper dimensions
                const framesCopy = frames.map(f => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = f.width;
                    tempCanvas.height = f.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(f, 0, 0);
                    return tempCtx.getImageData(0, 0, f.width, f.height);
                });
                
                undoStack.push({
                    frameIndex: currentFrameIndex,
                    framesCopy: framesCopy,
                    pixelArtMode: pixelArtMode
                });
                
                // Limit undo stack size
                if (undoStack.length > maxUndoStates) {
                    undoStack.shift();
                }
                
                // Clear redo stack when new action is performed
                redoStack = [];
            } catch(e) {
                console.error('Error saving state:', e);
            }
        }

        function undo() {
            if (undoStack.length === 0) return;
            
            try {
                // Save current state to redo stack
                const framesCopy = frames.map(f => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = f.width;
                    tempCanvas.height = f.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(f, 0, 0);
                    return tempCtx.getImageData(0, 0, f.width, f.height);
                });
                
                redoStack.push({
                    frameIndex: currentFrameIndex,
                    framesCopy: framesCopy,
                    pixelArtMode: pixelArtMode
                });
                
                // Restore previous state
                const prevState = undoStack.pop();
                currentFrameIndex = prevState.frameIndex;
                frames = prevState.framesCopy.map(f => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = f.width;
                    tempCanvas.height = f.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(f, 0, 0);
                    return tempCtx.getImageData(0, 0, f.width, f.height);
                });
                
                // Restore pixel art mode state if needed
                if (prevState.pixelArtMode !== pixelArtMode) {
                    pixelArtMode = prevState.pixelArtMode;
                    if (pixelArtMode) {
                        pixelScale = originalWidth / pixelArtWidth;
                        ctx.imageSmoothingEnabled = false;
                    } else {
                        pixelScale = 1;
                        ctx.imageSmoothingEnabled = true;
                    }
                }
                
                switchFrame(currentFrameIndex, false);
            } catch(e) {
                console.error('Error during undo:', e);
            }
        }

        function redo() {
            if (redoStack.length === 0) return;
            
            try {
                // Save current state to undo stack
                const framesCopy = frames.map(f => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = f.width;
                    tempCanvas.height = f.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(f, 0, 0);
                    return tempCtx.getImageData(0, 0, f.width, f.height);
                });
                
                undoStack.push({
                    frameIndex: currentFrameIndex,
                    framesCopy: framesCopy,
                    pixelArtMode: pixelArtMode
                });
                
                // Restore next state
                const nextState = redoStack.pop();
                currentFrameIndex = nextState.frameIndex;
                frames = nextState.framesCopy.map(f => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = f.width;
                    tempCanvas.height = f.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(f, 0, 0);
                    return tempCtx.getImageData(0, 0, f.width, f.height);
                });
                
                // Restore pixel art mode state if needed
                if (nextState.pixelArtMode !== pixelArtMode) {
                    pixelArtMode = nextState.pixelArtMode;
                    if (pixelArtMode) {
                        pixelScale = originalWidth / pixelArtWidth;
                        ctx.imageSmoothingEnabled = false;
                    } else {
                        pixelScale = 1;
                        ctx.imageSmoothingEnabled = true;
                    }
                }
                
                switchFrame(currentFrameIndex, false);
            } catch(e) {
                console.error('Error during redo:', e);
            }
        }

        // Pixel art mode functions
        function enterPixelArtMode() {
            if (pixelArtMode) return;
            
            pixelArtMode = true;
            pixelScale = originalWidth / pixelArtWidth;
            
            // Convert all frames to pixel art resolution
            const newFrames = [];
            for (let i = 0; i < frames.length; i++) {
                // Create temporary canvas with original frame
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalWidth;
                tempCanvas.height = originalHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(frames[i], 0, 0);
                
                // Downscale to pixel art resolution using nearest-neighbor
                const pixelCanvas = document.createElement('canvas');
                pixelCanvas.width = pixelArtWidth;
                pixelCanvas.height = pixelArtHeight;
                const pixelCtx = pixelCanvas.getContext('2d');
                pixelCtx.imageSmoothingEnabled = false;
                pixelCtx.drawImage(tempCanvas, 0, 0, originalWidth, originalHeight, 0, 0, pixelArtWidth, pixelArtHeight);
                
                // Get downscaled image data
                const imageData = pixelCtx.getImageData(0, 0, pixelArtWidth, pixelArtHeight);
                const data = imageData.data;
                
                // Quantize all colours to current palette
                for (let j = 0; j < data.length; j += 4) {
                    const r = data[j];
                    const g = data[j + 1];
                    const b = data[j + 2];
                    const a = data[j + 3];
                    
                    // Only quantize non-transparent pixels
                    if (a > 10) {
                        const quantisedColor = quantizeColorToPalette(r, g, b);
                        const hex = quantisedColor.replace('#', '');
                        data[j] = parseInt(hex.substr(0, 2), 16);
                        data[j + 1] = parseInt(hex.substr(2, 2), 16);
                        data[j + 2] = parseInt(hex.substr(4, 2), 16);
                    }
                }
                
                // Store quantised ImageData
                newFrames.push(imageData);
            }
            
            frames = newFrames;
            
            // Update canvas display
            ctx.imageSmoothingEnabled = false;
            switchFrame(currentFrameIndex);
        }
        
        function exitPixelArtMode() {
            if (!pixelArtMode) return;
            
            pixelArtMode = false;
            pixelScale = 1;
            
            // Convert all frames back to original resolution
            const newFrames = [];
            for (let i = 0; i < frames.length; i++) {
                // Create pixel art canvas
                const pixelCanvas = document.createElement('canvas');
                pixelCanvas.width = pixelArtWidth;
                pixelCanvas.height = pixelArtHeight;
                const pixelCtx = pixelCanvas.getContext('2d');
                pixelCtx.putImageData(frames[i], 0, 0);
                
                // Upscale to original resolution using nearest-neighbor
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalWidth;
                tempCanvas.height = originalHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.imageSmoothingEnabled = false;
                tempCtx.drawImage(pixelCanvas, 0, 0, pixelArtWidth, pixelArtHeight, 0, 0, originalWidth, originalHeight);
                
                // Store as ImageData
                newFrames.push(tempCtx.getImageData(0, 0, originalWidth, originalHeight));
            }
            
            frames = newFrames;
            
            // Update canvas display
            ctx.imageSmoothingEnabled = true;
            switchFrame(currentFrameIndex);
        }
        
        function drawPixelGrid() {
            if (!pixelArtMode) return;
            
            // Only draw grid if pixels are large enough (4√ó or more)
            if (pixelScale < 4) return;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.lineWidth = 1;
            
            // Draw vertical lines
            for (let x = 0; x <= originalWidth; x += pixelScale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, originalHeight);
                ctx.stroke();
            }
            
            // Draw horizontal lines
            for (let y = 0; y <= originalHeight; y += pixelScale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(originalWidth, y);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Stamp mode functions
        function convertToGrayscale(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                data[i] = gray;     // Red
                data[i + 1] = gray; // Green
                data[i + 2] = gray; // Blue
                // Alpha remains unchanged
            }
            return imageData;
        }

        function isCanvasEmpty() {
            // Check if current frame has any non-white pixels
            const imageData = frames[currentFrameIndex];
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                // Check if pixel is not white (255,255,255) or not fully transparent
                if (a > 0 && (r !== 255 || g !== 255 || b !== 255)) {
                    return false;
                }
            }
            return true;
        }

        function enterStampMode() {
            if (stampMode) return;
            
            // Check if canvas has existing art and warn user
            if (!isCanvasEmpty()) {
                const confirm = window.confirm('‚ö†Ô∏è Warning: Switching to Stamp Creator will clear all existing art on the canvas and start with a fresh black 512√ó512 canvas.\n\nDo you want to continue?');
                if (!confirm) {
                    return; // User cancelled
                }
            }
            
            // Exit pixel art mode if active
            if (pixelArtMode) {
                exitPixelArtMode();
            }
            
            // Exit timelapse mode if active
            if (timelapseMode) {
                timelapseMode = false;
                document.getElementById('timelapseChallenge').style.display = 'none';
                document.getElementById('startTimelapse').textContent = 'üé® Start Timelapse Challenge';
            }
            
            stampMode = true;
            
            // Store original palette
            originalPalette = {
                index: currentPaletteIndex,
                colors: [...colorPalette]
            };
            
            // Switch to grayscale palette
            colorPalette = [...grayscalePalette];
            initColorPalette();
            primaryBrush.color = grayscalePalette[19]; // Default to white
            
            // Select the white swatch (index 19)
            document.querySelectorAll('.color-swatch').forEach(swatch => swatch.classList.remove('selected'));
            document.querySelectorAll('.color-swatch')[19].classList.add('selected');
            
            // Resize canvas to 512x512
            canvas.width = stampWidth;
            canvas.height = stampHeight;
            
            // Clear all frames and start with fresh black canvas
            const newFrames = [];
            for (let i = 0; i < frames.length; i++) {
                // Create stamp-sized canvas
                const stampCanvas = document.createElement('canvas');
                stampCanvas.width = stampWidth;
                stampCanvas.height = stampHeight;
                const stampCtx = stampCanvas.getContext('2d');
                
                // Fill with black background
                stampCtx.fillStyle = 'black';
                stampCtx.fillRect(0, 0, stampWidth, stampHeight);
                
                // Get the black canvas as image data
                const imageData = stampCtx.getImageData(0, 0, stampWidth, stampHeight);
                
                newFrames.push(imageData);
            }
            
            frames = newFrames;
            
            // Update display
            ctx.imageSmoothingEnabled = true;
            switchFrame(currentFrameIndex);
            
            // Hide UI elements not needed in stamp mode
            document.getElementById('startTimelapse').style.display = 'none';
            document.querySelector('.animation-controls').style.display = 'none';
            document.getElementById('exportBrush').style.display = 'none';
            
            // Update button labels
            document.getElementById('export').textContent = 'Save STAMP';
            document.getElementById('loadCanvas').textContent = 'Load STAMP';
            
            // Update button
            document.getElementById('toggleStampMode').textContent = '‚úèÔ∏è Exit Stamp Mode';
            document.getElementById('toggleStampMode').style.background = 'linear-gradient(135deg, #f59fbe 0%, #f442a8 100%)';
            
            // If palette and controls are docked, switch to undocked layout
            if (!paletteFloating) {
                detachPalette();
            }
            if (!controlsFloating) {
                detachControls();
            }
            
            // Reposition floating boxes closer to the new smaller canvas
            if (paletteFloating) {
                const canvasRect = canvas.getBoundingClientRect();
                const palette = document.getElementById('colorPalette');
                const paletteWidth = palette.offsetWidth;
                palette.style.left = (canvasRect.left - paletteWidth - 10) + 'px';
                palette.style.top = '20px';
            }
            if (controlsFloating) {
                const canvasRect = canvas.getBoundingClientRect();
                const controls = document.getElementById('brushControls');
                controls.style.left = (canvasRect.right + 10) + 'px';
                controls.style.top = '20px';
            }
        }

        function exitStampMode() {
            if (!stampMode) return;
            
            stampMode = false;
            
            // Restore original palette
            if (originalPalette) {
                currentPaletteIndex = originalPalette.index;
                colorPalette = [...originalPalette.colors];
                initColorPalette();
                primaryBrush.color = colorPalette[10];
            }
            
            // Restore canvas to original size
            canvas.width = originalWidth;
            canvas.height = originalHeight;
            
            // Convert frames back to original resolution (upscale stamp)
            const newFrames = [];
            for (let i = 0; i < frames.length; i++) {
                // Create stamp canvas
                const stampCanvas = document.createElement('canvas');
                stampCanvas.width = stampWidth;
                stampCanvas.height = stampHeight;
                const stampCtx = stampCanvas.getContext('2d');
                stampCtx.putImageData(frames[i], 0, 0);
                
                // Create original-sized canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalWidth;
                tempCanvas.height = originalHeight;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Fill with white background
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, originalWidth, originalHeight);
                
                // Calculate scaling (reverse of enter logic)
                const scale = Math.min(stampWidth / originalWidth, stampHeight / originalHeight);
                const scaledWidth = originalWidth * scale;
                const scaledHeight = originalHeight * scale;
                const offsetX = (stampWidth - scaledWidth) / 2;
                const offsetY = (stampHeight - scaledHeight) / 2;
                
                // Extract the content area from stamp
                const contentCanvas = document.createElement('canvas');
                contentCanvas.width = scaledWidth;
                contentCanvas.height = scaledHeight;
                const contentCtx = contentCanvas.getContext('2d');
                contentCtx.drawImage(stampCanvas, offsetX, offsetY, scaledWidth, scaledHeight,
                                     0, 0, scaledWidth, scaledHeight);
                
                // Draw back to original size
                tempCtx.drawImage(contentCanvas, 0, 0, scaledWidth, scaledHeight,
                                  0, 0, originalWidth, originalHeight);
                
                // Store as ImageData
                newFrames.push(tempCtx.getImageData(0, 0, originalWidth, originalHeight));
            }
            
            frames = newFrames;
            
            // Update display
            switchFrame(currentFrameIndex);
            
            // Reposition floating boxes to edges of enlarged canvas
            if (paletteFloating) {
                const canvasRect = canvas.getBoundingClientRect();
                const palette = document.getElementById('colorPalette');
                const paletteWidth = palette.offsetWidth;
                palette.style.left = (canvasRect.left - paletteWidth - 10) + 'px';
                palette.style.top = '20px';
            }
            if (controlsFloating) {
                const canvasRect = canvas.getBoundingClientRect();
                const controls = document.getElementById('brushControls');
                controls.style.left = (canvasRect.right + 10) + 'px';
                controls.style.top = '20px';
            }
            
            // Restore UI elements
            document.getElementById('startTimelapse').style.display = '';
            document.querySelector('.animation-controls').style.display = '';
            document.getElementById('exportBrush').style.display = '';
            
            // Restore button labels
            document.getElementById('export').textContent = 'Save PNG';
            document.getElementById('loadCanvas').textContent = 'Load PNG';
            
            // Update button
            document.getElementById('toggleStampMode').textContent = 'üñåÔ∏è Stamp Creator';
            document.getElementById('toggleStampMode').style.background = 'linear-gradient(135deg, #000000 0%, #000000 100%)';
        }

        // Multiple color palettes
        const palettes = [
            {
                name: 'FARMLAND-20 by Eclipse89 (1)',
                colors: [
                    '#0c0f00', '#1c2025', '#2d3c56', '#536871', '#548ca4',
                    '#879797', '#8bb3c1', '#b8ddd2', '#ecf3b0', '#c8ad56',
                    '#8d9855', '#4b5431', '#7a7b6b', '#40291c', '#672d20',
                    '#725336', '#953a2f', '#9f865b', '#ac6b2f', '#50486a'
                ]
            },
            {
                name: 'ARTBOUND by Doph (2)',
                colors: [
                    '#403037', '#664f5c', '#ae8f9a', '#dbb7c2', '#fef7ef',
                    '#6475a1', '#a495c4', '#dda49c', '#c27b7f', '#b4666f',
                    '#fea47d', '#fdeead', '#c75061', '#8d4a5a', '#ffa7a4',
                    '#ffe5d1', '#6cb0b0', '#79b386', '#c08ed1', '#8b69a5'
                ]
            },
            {
                name: 'DUNGEON-20 by Meaghan (3)',
                colors: [
                    '#2e222f', '#45293f', '#7a3045', '#993d41', '#cd683d',
                    '#fbb954', '#28353e', '#344a5a', '#407080', '#508da0',
                    '#5bbfc5', '#f2ec8b', '#b0a987', '#997f73', '#665964',
                    '#443846', '#576069', '#788a87', '#d6dad3', '#a9b2a2'
                ]
            },
            {
                name: 'MIXEDBAG[20] by SoundsDotZip (4)',
                colors: [
                    '#000000', '#3b221c', '#69302b', '#99342c', '#b86735',
                    '#dba34f', '#899937', '#4c6933', '#383b21', '#2e4c5e',
                    '#5c7c94', '#8ab8ac', '#c28080', '#8a4368', '#4f284e',
                    '#261e2e', '#3e3f45', '#696163', '#9e9e98', '#e6d7cc'
                ]
            },
            {
                name: 'SOGGY 20 by green guy (5)',
                colors: [
                    '#efefef', '#d5cad8', '#968aa9', '#47425a', '#17111a',
                    '#a5e0d3', '#87baca', '#5d81ae', '#505389', '#362846',
                    '#afdabc', '#549482', '#3d4d4f', '#dde191', '#59b561',
                    '#3d805f', '#e6d6b1', '#d89879', '#a05248', '#56323e'
                ]
            },
            {
                name: 'ELEMENTAL by Space Sandwich (6)',
                colors: [
                    '#000000', '#555555', '#aaaaaa', '#ffffff', '#4b0f37',
                    '#9f1d2e', '#df5f36', '#f0a34a', '#f0cc69', '#beb866',
                    '#819650', '#497a3a', '#094d18', '#227944', '#449481',
                    '#63b9bb', '#8cdaff', '#7294d6', '#5959b3', '#5b2b7c'
                ]
            },
            {
                name: '20P DX by GrafxKid (7)',
                colors: [
                    '#170d20', '#474757', '#787876', '#b1b9a6', '#ebffda',
                    '#68293e', '#a94400', '#d97e00', '#ebd000', '#523c14',
                    '#816031', '#bc8b57', '#ebcd93', '#0e4c58', '#046e92',
                    '#01a3c3', '#55deb7', '#177947', '#5ab217', '#b1e329'
                ]
            },
            {
                name: 'MOJAVE20 by magodellepercussioni (8)',
                colors: [
                    '#dcd1b8', '#c8b496', '#aeb0b2', '#9196a0', '#60606a',
                    '#403f4a', '#38353e', '#4b444c', '#79625d', '#9e8676',
                    '#be9668', '#a46848', '#715a3b', '#453e2a', '#3f2926',
                    '#2e1515', '#17090c', '#541e13', '#d03c32', '#fba64c'
                ]
            },
            {
                name: 'GRAY WEATHER by Cactus Celery (9)',
                colors: [
                    '#bcafb6', '#a8a0aa', '#928d9a', '#7d7688', '#695a75',
                    '#503f58', '#3e3042', '#2d222e', '#989ea1', '#768c9c',
                    '#636e94', '#515670', '#40414e', '#b1a599', '#a09b72',
                    '#758672', '#57646e', '#a67c6a', '#98585b', '#6f3c50'
                ]
            }
        ];
        
        let currentPaletteIndex = 0;
        let colorPalette = palettes[currentPaletteIndex].colors;

        // Update display
        function updateFrameDisplay() {
            document.getElementById('currentFrame').textContent = currentFrameIndex + 1;
            document.getElementById('totalFrames').textContent = frames.length;
            document.getElementById('frameSlider').max = frames.length;
            document.getElementById('frameSlider').value = currentFrameIndex + 1;
        }

// Switch frames
function switchFrame(index, saveCurrent = true) {
    // Save the current frame's state before switching (only in normal mode and when actually switching)
    if (saveCurrent && !pixelArtMode && index !== currentFrameIndex) {
        frames[currentFrameIndex] = ctx.getImageData(0, 0, canvas.width, canvas.height);
    }
    
    // Clear canvas first
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (pixelArtMode) {
        // Pixel art mode: draw at pixel art resolution, then upscale
        const frameWidth = pixelArtWidth;
        const frameHeight = pixelArtHeight;
        
        // Draw onion skin first (if enabled)
        if (onionSkin && index > 0) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = frameWidth;
            tempCanvas.height = frameHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(frames[index - 1], 0, 0);
            
            ctx.globalAlpha = 0.3;
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempCanvas, 0, 0, frameWidth, frameHeight, 0, 0, originalWidth, originalHeight);
            ctx.globalAlpha = 1;
        }
        
        // Draw current frame upscaled
        const currentCanvas = document.createElement('canvas');
        currentCanvas.width = frameWidth;
        currentCanvas.height = frameHeight;
        const currentCtx = currentCanvas.getContext('2d');
        currentCtx.putImageData(frames[index], 0, 0);
        
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(currentCanvas, 0, 0, frameWidth, frameHeight, 0, 0, originalWidth, originalHeight);
        
        // Draw pixel grid overlay
        drawPixelGrid();
    } else {
        // Normal mode
        // Draw onion skin first (if enabled) using a temporary canvas
        if (onionSkin && index > 0) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(frames[index - 1], 0, 0);
            ctx.globalAlpha = 0.3;
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.globalAlpha = 1;
        }
        
        // Draw current frame on top using drawImage to preserve onion skin
        const currentCanvas = document.createElement('canvas');
        currentCanvas.width = canvas.width;
        currentCanvas.height = canvas.height;
        const currentCtx = currentCanvas.getContext('2d');
        currentCtx.putImageData(frames[index], 0, 0);
        ctx.drawImage(currentCanvas, 0, 0);
    }
    
    currentFrameIndex = index;
    updateFrameDisplay();
}        // Drawing functions
        function getBrushGradient(x, y, size, hardness, color) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gradient.addColorStop(0, color);
            gradient.addColorStop(hardness, color);
            gradient.addColorStop(1, color + '00'); // Fade to transparent
            return gradient;
        }

        // Helper function to adjust colour brightness
        function adjustBrightness(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
            const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
            const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }
        
        // Stroke stabilisation: Apply weighted averaging to point based on strength
        function stabilisePoint(current, buffer, strength) {
            if (buffer.length < 3) return current;
            
            // Calculate weighted average of recent points
            let totalWeight = 0;
            let smoothedX = 0;
            let smoothedY = 0;
            
            const lookback = Math.min(8, buffer.length); // Increased from 5 to 8 for better curve smoothing
            for (let i = 0; i < lookback; i++) {
                const weight = (lookback - i) / lookback; // More recent points have higher weight
                const point = buffer[buffer.length - 1 - i];
                smoothedX += point.x * weight;
                smoothedY += point.y * weight;
                totalWeight += weight;
            }
            
            smoothedX /= totalWeight;
            smoothedY /= totalWeight;
            
            // Blend between original and stabilised based on strength
            return {
                x: current.x * (1 - strength) + smoothedX * strength,
                y: current.y * (1 - strength) + smoothedY * strength
            };
        }

        // Colour quantisation: Find closest palette colour using Euclidean distance in RGB space
        function quantizeColorToPalette(r, g, b) {
            let minDistance = Infinity;
            let closestColor = colorPalette[0];
            
            for (let i = 0; i < colorPalette.length; i++) {
                const paletteColor = colorPalette[i];
                const hex = paletteColor.replace('#', '');
                const pr = parseInt(hex.substr(0, 2), 16);
                const pg = parseInt(hex.substr(2, 2), 16);
                const pb = parseInt(hex.substr(4, 2), 16);
                
                // Calculate Euclidean distance in RGB colour space
                const distance = Math.sqrt(
                    Math.pow(r - pr, 2) +
                    Math.pow(g - pg, 2) +
                    Math.pow(b - pb, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = paletteColor;
                }
            }
            
            return closestColor;
        }

        // Flood fill function
        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            
            // Convert fill colour to RGB
            const hex = fillColor.replace('#', '');
            const fillR = parseInt(hex.substr(0, 2), 16);
            const fillG = parseInt(hex.substr(2, 2), 16);
            const fillB = parseInt(hex.substr(4, 2), 16);
            
            // Get start pixel colour
            const startPos = (startY * canvas.width + startX) * 4;
            const startR = pixels[startPos];
            const startG = pixels[startPos + 1];
            const startB = pixels[startPos + 2];
            
            // Don't fill if same colour
            if (startR === fillR && startG === fillG && startB === fillB) {
                return;
            }
            
            // Stack-based flood fill to avoid recursion limits
            const stack = [[startX, startY]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key)) continue;
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                
                const pos = (y * canvas.width + x) * 4;
                const r = pixels[pos];
                const g = pixels[pos + 1];
                const b = pixels[pos + 2];
                
                // Check if pixel matches start colour
                if (r === startR && g === startG && b === startB) {
                    visited.add(key);
                    
                    // Fill pixel
                    pixels[pos] = fillR;
                    pixels[pos + 1] = fillG;
                    pixels[pos + 2] = fillB;
                    pixels[pos + 3] = 255; // Full opacity
                    
                    // Add neighbors to stack
                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function drawPixel(x, y, size, opacity, hardness, color, type, directionX = 0, directionY = 0) {
            ctx.save();
            ctx.globalAlpha = opacity;
            const halfSize = size / 2;
            
            // Calculate rotation angle based on rotation mode
            let rotationAngle = 0;
            if (rotationMode === 'follow') {
                rotationAngle = Math.atan2(directionY, directionX);
            } else if (rotationMode === 'random') {
                rotationAngle = Math.random() * Math.PI * 2;
            } else if (rotationMode === 'spin') {
                rotationAngle = spinAngle;
                spinAngle += 0.3; // Increment for next stamp
            }
            // rotationMode === 'none' keeps rotationAngle at 0
            
            // Apply rotation transformation if needed
            if (rotationAngle !== 0 && (type === 'square' || type === 'oil' || type === 'texture')) {
                ctx.translate(x, y);
                ctx.rotate(rotationAngle);
                ctx.translate(-x, -y);
            }
            if (type === 'round') {
                // Round brush with soft gradient edges
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, halfSize);
                gradient.addColorStop(0, color);
                gradient.addColorStop(Math.max(0.5, hardness), color);
                gradient.addColorStop(1, color + '00'); // Fade to transparent
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, halfSize, 0, 2 * Math.PI);
                ctx.fill();
            } else if (type === 'square') {
                ctx.fillStyle = color;
                ctx.fillRect(x - halfSize, y - halfSize, size, size);
            } else if (type === 'oil') {
                // Oil brush: Rectangular brush with colour mixing/contamination
                ctx.globalCompositeOperation = 'source-over';
                
                // Rectangle dimensions (2:1 ratio)
                const rectWidth = size;
                const rectHeight = size * 0.5;
                const rectX = x - rectWidth / 2;
                const rectY = y - rectHeight / 2;
                
                // Sample the underlying canvas colour for mixing
                let mixedColor = color;
                try {
                    const sampleX = Math.max(0, Math.min(canvas.width - 1, Math.floor(x)));
                    const sampleY = Math.max(0, Math.min(canvas.height - 1, Math.floor(y)));
                    const imageData = ctx.getImageData(sampleX, sampleY, 1, 1);
                    const pixel = imageData.data;
                    
                    // Extract underlying color
                    const underR = pixel[0];
                    const underG = pixel[1];
                    const underB = pixel[2];
                    const underAlpha = pixel[3];
                    
                    // Parse brush colour
                    const hex = color.replace('#', '');
                    const brushR = parseInt(hex.substr(0, 2), 16);
                    const brushG = parseInt(hex.substr(2, 2), 16);
                    const brushB = parseInt(hex.substr(4, 2), 16);
                    
                    // Mix colours: blend brush colour with underlying colour (30% contamination)
                    if (underAlpha > 50) { // Only mix if there's visible colour underneath
                        const mixRatio = 0.3;
                        const mixedR = Math.round(brushR * (1 - mixRatio) + underR * mixRatio);
                        const mixedG = Math.round(brushG * (1 - mixRatio) + underG * mixRatio);
                        const mixedB = Math.round(brushB * (1 - mixRatio) + underB * mixRatio);
                        mixedColor = `rgb(${mixedR}, ${mixedG}, ${mixedB})`;
                    }
                } catch(e) {
                    // Fallback to original colour if sampling fails
                    mixedColor = color;
                }
                
                // Main brush stroke - rectangular shape with opacity
                ctx.globalAlpha = opacity * 0.7;
                ctx.fillStyle = mixedColor;
                ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
                
                // Add directional edge highlights and shadows for rectangular shape
                const angle = Math.atan2(directionY, directionX);
                
                // Adjust brightness based on colour format
                let lightColor, darkColor;
                if (mixedColor.startsWith('rgb')) {
                    const match = mixedColor.match(/\d+/g);
                    const r = parseInt(match[0]);
                    const g = parseInt(match[1]);
                    const b = parseInt(match[2]);
                    lightColor = `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`;
                    darkColor = `rgb(${Math.max(0, r - 40)}, ${Math.max(0, g - 40)}, ${Math.max(0, b - 40)})`;
                } else {
                    lightColor = adjustBrightness(mixedColor, 40);
                    darkColor = adjustBrightness(mixedColor, -40);
                }
                
                // Lighter edge on leading side (rectangle)
                ctx.globalAlpha = opacity * 0.25;
                const lightOffsetX = Math.cos(angle) * rectWidth * 0.15;
                const lightOffsetY = Math.sin(angle) * rectHeight * 0.15;
                ctx.fillStyle = lightColor;
                ctx.fillRect(rectX + lightOffsetX, rectY + lightOffsetY, rectWidth * 0.7, rectHeight * 0.6);
                
                // Darker edge on trailing side (rectangle)
                ctx.globalAlpha = opacity * 0.2;
                const darkOffsetX = -Math.cos(angle) * rectWidth * 0.15;
                const darkOffsetY = -Math.sin(angle) * rectHeight * 0.15;
                ctx.fillStyle = darkColor;
                ctx.fillRect(rectX + darkOffsetX, rectY + darkOffsetY, rectWidth * 0.6, rectHeight * 0.5);
                
                // Add subtle texture (small rectangles)
                ctx.globalAlpha = opacity * 0.1;
                for (let i = 0; i < 6; i++) {
                    const tx = rectX + Math.random() * rectWidth * 0.8 + rectWidth * 0.1;
                    const ty = rectY + Math.random() * rectHeight * 0.8 + rectHeight * 0.1;
                    const twidth = rectWidth / 8;
                    const theight = rectHeight / 6;
                    const texColor = Math.random() > 0.5 ? lightColor : darkColor;
                    ctx.fillStyle = texColor;
                    ctx.fillRect(tx, ty, twidth, theight);
                }
                
                // Random edge smudging: sample and drag colors from the rectangular edges
                if (Math.random() > 0.3) { // 70% chance of smudging
                    const smudgeCount = Math.floor(Math.random() * 4) + 2; // 2-5 smudges
                    for (let i = 0; i < smudgeCount; i++) {
                        // Random position along rectangle perimeter
                        const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                        let edgeX, edgeY;
                        
                        if (edge === 0) { // Top edge
                            edgeX = rectX + Math.random() * rectWidth;
                            edgeY = rectY;
                        } else if (edge === 1) { // Right edge
                            edgeX = rectX + rectWidth;
                            edgeY = rectY + Math.random() * rectHeight;
                        } else if (edge === 2) { // Bottom edge
                            edgeX = rectX + Math.random() * rectWidth;
                            edgeY = rectY + rectHeight;
                        } else { // Left edge
                            edgeX = rectX;
                            edgeY = rectY + Math.random() * rectHeight;
                        }
                        
                        // Sample color at edge position
                        try {
                            const sampleX = Math.max(0, Math.min(canvas.width - 1, Math.floor(edgeX)));
                            const sampleY = Math.max(0, Math.min(canvas.height - 1, Math.floor(edgeY)));
                            const edgeImageData = ctx.getImageData(sampleX, sampleY, 1, 1);
                            const edgePixel = edgeImageData.data;
                            
                            if (edgePixel[3] > 50) { // Only smudge if there's visible color
                                const smudgeColor = `rgb(${edgePixel[0]}, ${edgePixel[1]}, ${edgePixel[2]})`;
                                
                                // Drag the sampled color slightly outward (smudge effect)
                                const smudgeOffsetX = (Math.random() - 0.5) * rectWidth * 0.2;
                                const smudgeOffsetY = (Math.random() - 0.5) * rectHeight * 0.2;
                                const smudgeX = edgeX + smudgeOffsetX;
                                const smudgeY = edgeY + smudgeOffsetY;
                                
                                // Draw smudge with random size (small rectangles)
                                const smudgeWidth = rectWidth * (0.08 + Math.random() * 0.08);
                                const smudgeHeight = rectHeight * (0.08 + Math.random() * 0.08);
                                ctx.globalAlpha = opacity * (0.15 + Math.random() * 0.15);
                                ctx.fillStyle = smudgeColor;
                                ctx.fillRect(smudgeX - smudgeWidth / 2, smudgeY - smudgeHeight / 2, smudgeWidth, smudgeHeight);
                            }
                        } catch(e) {
                            // Skip this smudge if sampling fails
                        }
                    }
                }
            } else if (type === 'daub') {
                // Daub brush: Mixes and smudges paint, creating new colours
                const blendRadius = Math.floor(halfSize);
                const sourceX = Math.max(0, Math.floor(x - blendRadius));
                const sourceY = Math.max(0, Math.floor(y - blendRadius));
                const blendSize = Math.min(size, canvas.width - sourceX, canvas.height - sourceY);
                
                if (blendSize > 0) {
                    // Sample the current area and areas around it for colour mixing
                    const imageData = ctx.getImageData(sourceX, sourceY, blendSize, blendSize);
                    const data = imageData.data;
                    
                    // Calculate average colour in the brush area for mixing
                    let totalR = 0, totalG = 0, totalB = 0, totalA = 0;
                    let pixelCount = 0;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const alpha = data[i + 3];
                        if (alpha > 0) {
                            totalR += data[i] * alpha;
                            totalG += data[i + 1] * alpha;
                            totalB += data[i + 2] * alpha;
                            totalA += alpha;
                            pixelCount++;
                        }
                    }
                    
                    if (totalA > 0) {
                        // Calculate mixed colour
                        const avgR = Math.round(totalR / totalA);
                        const avgG = Math.round(totalG / totalA);
                        const avgB = Math.round(totalB / totalA);
                        const mixedColor = `rgb(${avgR}, ${avgG}, ${avgB})`;
                        
                        // Calculate smudge direction
                        const smudgeDistance = size * 0.4 * opacity;
                        const angle = Math.atan2(directionY, directionX);
                        const offsetX = Math.cos(angle) * smudgeDistance;
                        const offsetY = Math.sin(angle) * smudgeDistance;
                        
                        // Apply the mixed colour with a gradient effect
                        ctx.globalCompositeOperation = 'source-over';
                        
                        // Draw several overlapping layers to create smooth colour mixing
                        for (let layer = 0; layer < 5; layer++) {
                            const layerProgress = layer / 4;
                            const layerX = x + offsetX * layerProgress;
                            const layerY = y + offsetY * layerProgress;
                            
                            ctx.globalAlpha = opacity * (0.25 - layer * 0.03);
                            ctx.fillStyle = mixedColor;
                            ctx.beginPath();
                            ctx.arc(layerX, layerY, halfSize * (0.9 - layer * 0.1), 0, 2 * Math.PI);
                            ctx.fill();
                        }
                        
                        // Also move some of the original pixels for texture
                        ctx.globalAlpha = opacity * 0.4;
                        ctx.putImageData(imageData, sourceX + offsetX * 0.7, sourceY + offsetY * 0.7);
                    }
                }
            } else if (type === 'pixel') {
                // Pixel brush: Pixel-perfect drawing for pixel art
                if (!pixelArtMode) return;
                
                // Convert canvas coordinates to pixel art coordinates
                const pixelX = Math.floor(x / pixelScale);
                const pixelY = Math.floor(y / pixelScale);
                
                // Get current frame's pixel data
                const frameWidth = pixelArtWidth;
                const frameHeight = pixelArtHeight;
                
                // Bounds check
                if (pixelX < 0 || pixelX >= frameWidth || pixelY < 0 || pixelY >= frameHeight) return;
                
                // Get the current frame as ImageData
                const imageData = frames[currentFrameIndex];
                const data = imageData.data;
                
                // Parse colour to RGB
                const hex = color.replace('#', '');
                let r = parseInt(hex.substr(0, 2), 16);
                let g = parseInt(hex.substr(2, 2), 16);
                let b = parseInt(hex.substr(4, 2), 16);
                
                // Quantize color to current palette (standard pixel art technique)
                const quantisedColor = quantizeColorToPalette(r, g, b);
                const quantisedHex = quantisedColor.replace('#', '');
                r = parseInt(quantisedHex.substr(0, 2), 16);
                g = parseInt(quantisedHex.substr(2, 2), 16);
                b = parseInt(quantisedHex.substr(4, 2), 16);
                
                // Calculate brush size in pixels (1-4 pixels)
                const pixelBrushSize = Math.max(1, Math.min(4, Math.floor(size / 10)));
                
                // Draw square of pixels
                for (let py = 0; py < pixelBrushSize; py++) {
                    for (let px = 0; px < pixelBrushSize; px++) {
                        const drawX = pixelX - Math.floor(pixelBrushSize / 2) + px;
                        const drawY = pixelY - Math.floor(pixelBrushSize / 2) + py;
                        
                        if (drawX >= 0 && drawX < frameWidth && drawY >= 0 && drawY < frameHeight) {
                            const idx = (drawY * frameWidth + drawX) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                            data[idx + 3] = 255; // Full opacity
                        }
                    }
                }
                
                // Immediately update the display
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = frameWidth;
                tempCanvas.height = frameHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(imageData, 0, 0);
                
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(tempCanvas, 0, 0, frameWidth, frameHeight, 0, 0, originalWidth, originalHeight);
                drawPixelGrid();
            } else if (type === 'render') {
                // Render brush: Applies selective blur locally
                const renderRadius = Math.floor(halfSize);
                const areaX = Math.max(0, Math.floor(x - renderRadius));
                const areaY = Math.max(0, Math.floor(y - renderRadius));
                const areaWidth = Math.min(size, canvas.width - areaX);
                const areaHeight = Math.min(size, canvas.height - areaY);
                
                if (areaWidth > 0 && areaHeight > 0) {
                    // Helper: Calculate luminance for edge detection
                    function getLuminance(r, g, b) {
                        return 0.299 * r + 0.587 * g + 0.114 * b;
                    }
                    
                    // Get the area to process
                    const imageData = ctx.getImageData(areaX, areaY, areaWidth, areaHeight);
                    const data = imageData.data;
                    const originalData = new Uint8ClampedArray(data);
                    
                    // Selective blur parameters
                    const blurRadius = 2;
                    const contrastThreshold = 80;
                    
                    // Process each pixel in the brush area
                    for (let py = 0; py < areaHeight; py++) {
                        for (let px = 0; px < areaWidth; px++) {
                            const idx = (py * areaWidth + px) * 4;
                            
                            // Skip transparent pixels
                            const alpha = originalData[idx + 3];
                            if (alpha < 10) continue;
                            
                            // Check if pixel is within circular brush
                            const dx = px - renderRadius;
                            const dy = py - renderRadius;
                            const distFromCenter = Math.sqrt(dx * dx + dy * dy);
                            if (distFromCenter > renderRadius) continue;
                            
                            const centerR = originalData[idx];
                            const centerG = originalData[idx + 1];
                            const centerB = originalData[idx + 2];
                            const centerLum = getLuminance(centerR, centerG, centerB);
                            
                            let sumR = 0, sumG = 0, sumB = 0, count = 0;
                            
                            // Sample neighboring pixels
                            for (let dy = -blurRadius; dy <= blurRadius; dy++) {
                                for (let dx = -blurRadius; dx <= blurRadius; dx++) {
                                    const nx = px + dx;
                                    const ny = py + dy;
                                    
                                    // Boundary check
                                    if (nx < 0 || nx >= areaWidth || ny < 0 || ny >= areaHeight) continue;
                                    
                                    const nIdx = (ny * areaWidth + nx) * 4;
                                    const nAlpha = originalData[nIdx + 3];
                                    
                                    // Skip transparent pixels
                                    if (nAlpha < 10) continue;
                                    
                                    const nR = originalData[nIdx];
                                    const nG = originalData[nIdx + 1];
                                    const nB = originalData[nIdx + 2];
                                    const nLum = getLuminance(nR, nG, nB);
                                    
                                    // Only blend similar tones
                                    const lumDiff = Math.abs(centerLum - nLum);
                                    if (lumDiff < contrastThreshold) {
                                        const distance = Math.sqrt(dx * dx + dy * dy);
                                        const weight = 1 / (1 + distance);
                                        
                                        sumR += nR * weight;
                                        sumG += nG * weight;
                                        sumB += nB * weight;
                                        count += weight;
                                    }
                                }
                            }
                            
                            // Apply blended color
                            if (count > 0) {
                                const blendedR = sumR / count;
                                const blendedG = sumG / count;
                                const blendedB = sumB / count;
                                
                                // Apply opacity for brush strength control
                                const blendStrength = opacity * 0.85;
                                data[idx] = Math.round(blendedR * blendStrength + centerR * (1 - blendStrength));
                                data[idx + 1] = Math.round(blendedG * blendStrength + centerG * (1 - blendStrength));
                                data[idx + 2] = Math.round(blendedB * blendStrength + centerB * (1 - blendStrength));
                            }
                        }
                    }
                    
                    // Apply the processed area back to canvas
                    ctx.putImageData(imageData, areaX, areaY);
                }
            } else if (type === 'texture') {
                // Texture brush: Stamp-based rendering with custom texture (square, respects PNG transparency)
                if (!brushTexture || !textureLoaded) {
                    // Fallback to square brush if no texture loaded
                    if (!textureLoaded) {
                        console.warn('‚ö†Ô∏è Texture not loaded yet, using fallback square brush');
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(x - halfSize, y - halfSize, size, size);
                } else {
                    // Create temporary canvas for texture stamp
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = size;
                    tempCanvas.height = size;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Use rotation angle calculated at start of function
                    const angle = rotationAngle;
                    
                    // Random offset for texture sampling (prevents repetition)
                    const textureOffsetX = Math.random() * brushTexture.width;
                    const textureOffsetY = Math.random() * brushTexture.height;
                    
                    // Apply rotation around center
                    tempCtx.translate(size / 2, size / 2);
                    tempCtx.rotate(angle);
                    tempCtx.translate(-size / 2, -size / 2);
                    
                    // Draw texture scaled to brush size (preserves transparency)
                    tempCtx.drawImage(brushTexture, 0, 0, size, size);
                    
                    // Apply color tint using source-atop (preserves alpha channel)
                    tempCtx.globalCompositeOperation = 'source-atop';
                    tempCtx.fillStyle = color;
                    tempCtx.fillRect(0, 0, size, size);
                    
                    // Apply opacity control
                    tempCtx.globalCompositeOperation = 'destination-in';
                    tempCtx.globalAlpha = opacity;
                    tempCtx.fillStyle = 'rgba(255,255,255,1)';
                    tempCtx.fillRect(0, 0, size, size);
                    
                    // Composite texture stamp to main canvas
                    ctx.globalAlpha = 1;
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.drawImage(tempCanvas, x - size / 2, y - size / 2);
                }
            }
            ctx.restore();
        }

        function drawStroke(e) {
            const rect = canvas.getBoundingClientRect();
            let x = (e.clientX || e.touches[0].clientX) - rect.left;
            let y = (e.clientY || e.touches[0].clientY) - rect.top;

            if (!isDrawing) {
                lastX = x;
                lastY = y;
                return;
            }

            // Skip if lastX or lastY is null (new stroke)
            if (lastX === null || lastY === null) {
                lastX = x;
                lastY = y;
                return;
            }
            
            // Apply stabilisation if enabled
            if (stabilisationEnabled) {
                strokePoints.push({ x, y });
                const stabilised = stabilisePoint({ x, y }, strokePoints, stabilisationStrength);
                x = stabilised.x;
                y = stabilised.y;
            }

            // Get current brush settings
            primaryBrush.size = parseInt(document.getElementById('brushSize').value);
            primaryBrush.opacity = parseFloat(document.getElementById('brushOpacity').value);
            primaryBrush.hardness = parseFloat(document.getElementById('brushHardness').value);
            primaryBrush.spacing = parseFloat(document.getElementById('brushSpacing').value);
            primaryBrush.flow = parseFloat(document.getElementById('brushFlow').value);
            primaryBrush.scatter = parseInt(document.getElementById('brushScatter').value);
            primaryBrush.taper = parseFloat(document.getElementById('brushTaper').value);
            primaryBrush.jitter = parseFloat(document.getElementById('brushJitter').value);
            // Colour is now managed by palette clicks, not input element
            primaryBrush.type = document.getElementById('brushType').value;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Calculate brush direction for oil brush
            const distance = Math.sqrt((x - lastX) ** 2 + (y - lastY) ** 2);
            const directionX = distance > 0 ? (x - lastX) / distance : 0;
            const directionY = distance > 0 ? (y - lastY) / distance : 0;

            // Update stroke length for taper calculation
            strokeLength += distance;

            // Calculate taper based on stroke progress (traditional brush pressure simulation)
            let taperMultiplier = 1.0;
            if (primaryBrush.taper > 0) {
                // Traditional brush pressure curve with dynamic start phase:
                // Start phase length controlled by TAPER slider (0-60% of stroke)
                // Middle phase: remaining time for full pressure
                // End phase: taper off at the end
                
                // Estimate total stroke length for progress calculation
                // Use a moving average of recent stroke lengths for better prediction
                const estimatedTotalLength = Math.max(strokeLength * 2, 100); // Conservative estimate
                const progress = Math.min(strokeLength / estimatedTotalLength, 1.0);
                
                // Dynamic phase percentages based on taper value
                const startPhasePercent = primaryBrush.taper * 0.8; // 0% to 80% of stroke for tip-to-full transition
                const middlePhasePercent = Math.max(0.05, (1.0 - startPhasePercent) * 0.7); // 70% of remaining time for full pressure (minimum 5%)
                const endPhasePercent = Math.max(0.05, 1.0 - startPhasePercent - middlePhasePercent); // Rest for tapering off (minimum 5%)
                
                let pressureMultiplier = 1.0;
                
                if (progress < startPhasePercent) {
                    // Start: linear increase from tip (0.1) to full pressure (1.0)
                    // At TAPER=1.0, this takes 80% of the stroke!
                    pressureMultiplier = 0.1 + (progress / startPhasePercent) * 0.9;
                } else if (progress < startPhasePercent + middlePhasePercent) {
                    // Middle: full pressure
                    pressureMultiplier = 1.0;
                } else {
                    // End: linear decrease from full pressure (1.0) to tip (0.1)
                    const endProgress = (progress - startPhasePercent - middlePhasePercent) / endPhasePercent;
                    pressureMultiplier = Math.max(0.1, 1.0 - endProgress * 0.9);
                }
                
                // Blend between no taper (1.0) and pressure-based taper
                taperMultiplier = 1.0 * (1 - primaryBrush.taper) + pressureMultiplier * primaryBrush.taper;
            }

            // Apply spacing control to interpolation steps
            if (spacingSpeedMode) {
                // Fixed mode: accumulate distance and place stamps at exact spacing intervals
                accumulatedDistance += distance;
                const fixedSpacing = primaryBrush.size * primaryBrush.spacing;
                
                while (accumulatedDistance >= fixedSpacing) {
                    // Calculate position along the stroke where stamp should be placed
                    const ratio = (accumulatedDistance - fixedSpacing) / distance;
                    const interpX = x - (x - lastX) * ratio;
                    const interpY = y - (y - lastY) * ratio;
                    
                    // Calculate taper based on stroke progress (traditional brush pressure simulation)
                    let taperMultiplier = 1.0;
                    if (primaryBrush.taper > 0) {
                        // Traditional brush pressure curve with dynamic start phase:
                        // Start phase length controlled by TAPER slider (0-60% of stroke)
                        // Middle phase: remaining time for full pressure
                        // End phase: taper off at the end
                        
                        // Use strokeProgress for progress calculation in fixed spacing mode
                        const estimatedTotalLength = Math.max(strokeLength * 2, 100); // Conservative estimate
                        const progress = Math.min(strokeProgress / estimatedTotalLength, 1.0);
                        
                        // Dynamic phase percentages based on taper value
                        const startPhasePercent = primaryBrush.taper * 0.8; // 0% to 80% of stroke for tip-to-full transition
                        const middlePhasePercent = Math.max(0.05, (1.0 - startPhasePercent) * 0.7); // 70% of remaining time for full pressure (minimum 5%)
                        const endPhasePercent = Math.max(0.05, 1.0 - startPhasePercent - middlePhasePercent); // Rest for tapering off (minimum 5%)
                        
                        let pressureMultiplier = 1.0;
                        
                        if (progress < startPhasePercent) {
                            // Start: linear increase from tip (0.1) to full pressure (1.0)
                            // At TAPER=1.0, this takes 60% of the stroke!
                            pressureMultiplier = 0.1 + (progress / startPhasePercent) * 0.9;
                        } else if (progress < startPhasePercent + middlePhasePercent) {
                            // Middle: full pressure
                            pressureMultiplier = 1.0;
                        } else {
                            // End: linear decrease from full pressure (1.0) to tip (0.1)
                            const endProgress = (progress - startPhasePercent - middlePhasePercent) / endPhasePercent;
                            pressureMultiplier = Math.max(0.1, 1.0 - endProgress * 0.9);
                        }
                        
                        // Blend between no taper (1.0) and pressure-based taper
                        taperMultiplier = 1.0 * (1 - primaryBrush.taper) + pressureMultiplier * primaryBrush.taper;
                    }
                    
                    // Apply scatter (random offset)
                    const scatterX = interpX + (Math.random() - 0.5) * primaryBrush.scatter;
                    const scatterY = interpY + (Math.random() - 0.5) * primaryBrush.scatter;
                    
                    // Apply jitter (random size and opacity variation)
                    const sizeJitter = primaryBrush.jitter > 0 ? 1.0 - (Math.random() * primaryBrush.jitter * 0.5) : 1.0;
                    const opacityJitter = primaryBrush.jitter > 0 ? 1.0 - (Math.random() * primaryBrush.jitter * 0.3) : 1.0;
                    
                    // Apply taper to size and flow
                    const taperedSize = primaryBrush.size * taperMultiplier * sizeJitter;
                    const flowOpacity = primaryBrush.opacity * primaryBrush.flow * opacityJitter;
                    
                    drawPixel(scatterX, scatterY, taperedSize, flowOpacity, primaryBrush.hardness, primaryBrush.color, primaryBrush.type, directionX, directionY);
                    
                    // Dual brush
                    if (dualBrushEnabled) {
                        const dualScatterX = scatterX + (Math.random() - 0.5) * secondaryBrush.scatter + primaryBrush.size * 0.5;
                        const dualScatterY = scatterY + (Math.random() - 0.5) * secondaryBrush.scatter;
                        const dualFlowOpacity = secondaryBrush.opacity * secondaryBrush.flow;
                        drawPixel(dualScatterX, dualScatterY, primaryBrush.size * 0.5, dualFlowOpacity, secondaryBrush.hardness, secondaryBrush.color, secondaryBrush.type, directionX, directionY);
                    }
                    
                    accumulatedDistance -= fixedSpacing;
                    strokeProgress += fixedSpacing;
                }
            } else {
                // Standard mode: spacing relative to brush size (allows overlap when < 1.0)
                const steps = Math.max(1, distance / (primaryBrush.size * primaryBrush.spacing));
                for (let i = 0; i <= steps; i++) {
                    const interpX = lastX + (x - lastX) * (i / steps);
                    const interpY = lastY + (y - lastY) * (i / steps);
                    
                    // Calculate taper based on stroke progress (traditional brush pressure simulation)
                    let taperMultiplier = 1.0;
                    if (primaryBrush.taper > 0) {
                        // Traditional brush pressure curve with dynamic start phase:
                        // Start phase length controlled by TAPER slider (0-60% of stroke)
                        // Middle phase: remaining time for full pressure
                        // End phase: taper off at the end
                        
                        // Use strokeLength for progress calculation in standard mode
                        const estimatedTotalLength = Math.max(strokeLength * 2, 100); // Conservative estimate
                        const progress = Math.min(strokeLength / estimatedTotalLength, 1.0);
                        
                        // Dynamic phase percentages based on taper value
                        const startPhasePercent = primaryBrush.taper * 0.8; // 0% to 80% of stroke for tip-to-full transition
                        const middlePhasePercent = Math.max(0.05, (1.0 - startPhasePercent) * 0.7); // 70% of remaining time for full pressure (minimum 5%)
                        const endPhasePercent = Math.max(0.05, 1.0 - startPhasePercent - middlePhasePercent); // Rest for tapering off (minimum 5%)
                        
                        let pressureMultiplier = 1.0;
                        
                        if (progress < startPhasePercent) {
                            // Start: linear increase from tip (0.1) to full pressure (1.0)
                            // At TAPER=1.0, this takes 60% of the stroke!
                            pressureMultiplier = 0.1 + (progress / startPhasePercent) * 0.9;
                        } else if (progress < startPhasePercent + middlePhasePercent) {
                            // Middle: full pressure
                            pressureMultiplier = 1.0;
                        } else {
                            // End: linear decrease from full pressure (1.0) to tip (0.1)
                            const endProgress = (progress - startPhasePercent - middlePhasePercent) / endPhasePercent;
                            pressureMultiplier = Math.max(0.1, 1.0 - endProgress * 0.9);
                        }
                        
                        // Blend between no taper (1.0) and pressure-based taper
                        taperMultiplier = 1.0 * (1 - primaryBrush.taper) + pressureMultiplier * primaryBrush.taper;
                    }
                    
                    // Apply scatter (random offset)
                    const scatterX = interpX + (Math.random() - 0.5) * primaryBrush.scatter;
                    const scatterY = interpY + (Math.random() - 0.5) * primaryBrush.scatter;
                    
                    // Apply jitter (random size and opacity variation)
                    const sizeJitter = primaryBrush.jitter > 0 ? 1.0 - (Math.random() * primaryBrush.jitter * 0.5) : 1.0;
                    const opacityJitter = primaryBrush.jitter > 0 ? 1.0 - (Math.random() * primaryBrush.jitter * 0.3) : 1.0;
                    
                    // Apply taper to size and flow
                    const taperedSize = primaryBrush.size * taperMultiplier * sizeJitter;
                    const flowOpacity = primaryBrush.opacity * primaryBrush.flow * opacityJitter;
                    
                    drawPixel(scatterX, scatterY, taperedSize, flowOpacity, primaryBrush.hardness, primaryBrush.color, primaryBrush.type, directionX, directionY);

                    // Dual brush: Overlay secondary brush at every step for better color mix
                    if (dualBrushEnabled) {
                        const dualScatterX = scatterX + (Math.random() - 0.5) * secondaryBrush.scatter + primaryBrush.size * 0.5;
                        const dualScatterY = scatterY + (Math.random() - 0.5) * secondaryBrush.scatter;
                        const dualFlowOpacity = secondaryBrush.opacity * secondaryBrush.flow;
                        drawPixel(dualScatterX, dualScatterY, primaryBrush.size * 0.5, dualFlowOpacity, secondaryBrush.hardness, secondaryBrush.color, secondaryBrush.type, directionX, directionY);
                    }
                }
            }

            lastX = x;
            lastY = y;
            lastMoveTime = Date.now();
        }

        // Event listeners for drawing
        function startDrawing(e) {
            e.preventDefault();
            
            // Eyedropper mode: pick colour
            if (eyedropperMode) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX || e.touches[0].clientX) - rect.left);
                const y = Math.floor((e.clientY || e.touches[0].clientY) - rect.top);
                
                // Get pixel colour at click position
                const imageData = ctx.getImageData(x, y, 1, 1);
                const pixel = imageData.data;
                const r = pixel[0];
                const g = pixel[1];
                const b = pixel[2];
                
                // Convert to hex
                const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                
                // Set brush colour and update palette selection
                primaryBrush.color = hex.toUpperCase();
                
                // Try to select matching palette colour if it exists
                const swatches = document.querySelectorAll('.color-swatch');
                swatches.forEach(swatch => {
                    swatch.classList.remove('selected');
                    if (swatch.style.backgroundColor.toUpperCase() === hex.toUpperCase() ||
                        rgbToHex(swatch.style.backgroundColor).toUpperCase() === hex.toUpperCase()) {
                        swatch.classList.add('selected');
                    }
                });
                
                // Exit eyedropper mode and restore previous brush
                eyedropperMode = false;
                document.getElementById('eyedropper').textContent = 'üé® Eyedropper';
                document.getElementById('brushType').value = previousBrushType;
                updateCursor();
                return;
            }
            
            // Block drawing if timelapse challenge is complete
            if (drawingBlocked) {
                return;
            }
            
            // Get click position
            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX || e.touches[0].clientX) - rect.left;
            const clickY = (e.clientY || e.touches[0].clientY) - rect.top;
            
            // Check if fill tool is selected
            const brushType = document.getElementById('brushType').value;
            if (brushType === 'fill') {
                // Save state BEFORE fill operation
                saveState();
                
                // Fill mode: perform flood fill on click
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.putImageData(frames[currentFrameIndex], 0, 0);
                
                const x = Math.floor(clickX);
                const y = Math.floor(clickY);
                
                const fillColor = primaryBrush.color;
                floodFill(x, y, fillColor);
                
                // Save the filled state
                frames[currentFrameIndex] = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Redraw with onion skin if enabled
                if (onionSkin && currentFrameIndex > 0) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(frames[currentFrameIndex - 1], 0, 0);
                    ctx.globalAlpha = 0.3;
                    ctx.drawImage(tempCanvas, 0, 0);
                    ctx.globalAlpha = 1;
                    const currentCanvas = document.createElement('canvas');
                    currentCanvas.width = canvas.width;
                    currentCanvas.height = canvas.height;
                    const currentCtx = currentCanvas.getContext('2d');
                    currentCtx.putImageData(frames[currentFrameIndex], 0, 0);
                    ctx.drawImage(currentCanvas, 0, 0);
                }
                
                // Capture snapshot for timelapse if active
                if (timelapseMode && strokesRemaining > 0) {
                    const snapshotCanvas = document.createElement('canvas');
                    snapshotCanvas.width = canvas.width;
                    snapshotCanvas.height = canvas.height;
                    const snapshotCtx = snapshotCanvas.getContext('2d');
                    snapshotCtx.putImageData(frames[currentFrameIndex], 0, 0);
                    timelapseSnapshots.push(snapshotCanvas.toDataURL('image/png'));
                    strokesRemaining--;
                    document.getElementById('strokeCount').textContent = strokesRemaining;
                    if (strokesRemaining === 0) {
                        drawingBlocked = true;
                        document.getElementById('exportTimelapse').disabled = false;
                        document.getElementById('strokeCount').textContent = '0 - Challenge Complete!';
                        alert('üéâ Challenge Complete! You can now export your timelapse.');
                    }
                }
                
                return; // Don't start normal drawing
            }
            
            // Save state BEFORE starting to draw (so we can undo TO this point)
            saveState();
            
            isDrawing = true;
            // Reset taper tracking for new stroke
            strokeProgress = 0;
            strokeLength = 0;
            accumulatedDistance = 0;
            // Reset stabilisation buffer
            strokePoints = [];
            // Reset spin angle for new stroke
            if (rotationMode === 'spin') {
                spinAngle = 0;
            }
            
            // Set lastX and lastY to the current position to start a fresh stroke
            lastX = clickX;
            lastY = clickY;
            
            // Reset time tracking for speed-based taper
            lastMoveTime = Date.now();
            
            // Draw immediately on click (not just on drag)
            primaryBrush.size = parseInt(document.getElementById('brushSize').value);
            primaryBrush.opacity = parseFloat(document.getElementById('brushOpacity').value);
            primaryBrush.hardness = parseFloat(document.getElementById('brushHardness').value);
            primaryBrush.color = primaryBrush.color; // Already set
            primaryBrush.type = brushType;
            
            // Draw a single pixel at click position (skip if taper is enabled)
            const taperValue = parseFloat(document.getElementById('brushTaper').value);
            if (primaryBrush.flow > 0.1 && taperValue === 0) {
                drawPixel(clickX, clickY, primaryBrush.size, primaryBrush.opacity, primaryBrush.hardness, primaryBrush.color, primaryBrush.type, 0, 0);
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            // Check if cursor is within canvas bounds
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX)) - rect.left;
            const y = (e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY)) - rect.top;
            
            // Only draw if within canvas bounds
            if (x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height) {
                drawStroke(e);
            }
        }

        // Replace the existing stopDrawing function
        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            
            // Save the current state
            // Note: In pixel art mode, frames are already at pixel art resolution
            // The frame data is modified directly by the pixel brush
            if (!pixelArtMode) {
                frames[currentFrameIndex] = ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
            
            // Timelapse mode: capture snapshot after each stroke
            if (timelapseMode && strokesRemaining > 0) {
                // Create snapshot canvas
                const snapshotCanvas = document.createElement('canvas');
                snapshotCanvas.width = canvas.width;
                snapshotCanvas.height = canvas.height;
                const snapshotCtx = snapshotCanvas.getContext('2d');
                snapshotCtx.putImageData(frames[currentFrameIndex], 0, 0);
                
                // Store as data URL (more memory efficient than keeping canvas objects)
                timelapseSnapshots.push(snapshotCanvas.toDataURL('image/png'));
                
                // Decrement strokes
                strokesRemaining--;
                document.getElementById('strokeCount').textContent = strokesRemaining;
                
                // Check if challenge is complete
                if (strokesRemaining === 0) {
                    drawingBlocked = true;
                    document.getElementById('exportTimelapse').disabled = false;
                    document.getElementById('strokeCount').textContent = '0 - Challenge Complete!';
                    alert('üéâ Challenge Complete! You can now export your timelapse.');
                }
            }
            
            // Redraw with onion skin if enabled using a temporary canvas
            if (onionSkin && currentFrameIndex > 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw previous frame with transparency
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(frames[currentFrameIndex - 1], 0, 0);
                ctx.globalAlpha = 0.3;
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.globalAlpha = 1;
                
                // Draw current frame on top using drawImage to preserve onion skin
                const currentCanvas = document.createElement('canvas');
                currentCanvas.width = canvas.width;
                currentCanvas.height = canvas.height;
                const currentCtx = currentCanvas.getContext('2d');
                currentCtx.putImageData(frames[currentFrameIndex], 0, 0);
                ctx.drawImage(currentCanvas, 0, 0);
            }
            
            // Reset lastX and lastY to prevent connecting to the next stroke
            lastX = null;
            lastY = null;
            // Clear stabilisation buffer
            strokePoints = [];
        }

        // Mouse events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        // Remove mouseout to allow continuous drawing when cursor leaves canvas
        document.addEventListener('mouseup', stopDrawing); // Listen globally for mouse release

        // Touch events
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        // Controls
        document.getElementById('brushSize').addEventListener('input', (e) => { 
            document.getElementById('brushSizeValue').textContent = e.target.value;
            updateCursor(); // Update cursor when size changes
        });
        let pendingOpacityFineSwitch = false;
        let pendingOpacityNormalSwitch = false;
        
        document.getElementById('brushOpacity').addEventListener('input', (e) => {
            const slider = e.target;
            const value = parseFloat(slider.value);
            
            // Check for scale mode switching
            if (!opacityFineMode && value === 0.1) {
                // Switch to fine mode (0-0.1 scale) - will set to 0.09 on mouseup
                opacityFineMode = true;
                pendingOpacityFineSwitch = true;
                slider.min = '0';
                slider.max = '0.1';
                slider.step = '0.01';
                slider.classList.add('opacity-fine-mode');
                document.getElementById('brushOpacityValue').textContent = '0.10 fine';
            } else if (opacityFineMode && value === 0.1) {
                // Switch back to normal mode (0.1-1.0 scale) - will set to 0.1 on mouseup
                opacityFineMode = false;
                pendingOpacityNormalSwitch = true;
                slider.min = '0.1';
                slider.max = '1';
                slider.step = '0.1';
                slider.classList.remove('opacity-fine-mode');
                document.getElementById('brushOpacityValue').textContent = '0.10';
            } else {
                // Normal display update
                const displayValue = value.toFixed(opacityFineMode ? 2 : 1);
                document.getElementById('brushOpacityValue').textContent = opacityFineMode ? displayValue + ' fine' : displayValue;
            }
        });
        
        document.getElementById('brushOpacity').addEventListener('mouseup', (e) => {
            const slider = e.target;
            if (pendingOpacityFineSwitch) {
                slider.value = '0.09';
                document.getElementById('brushOpacityValue').textContent = '0.09 fine';
                pendingOpacityFineSwitch = false;
            } else if (pendingOpacityNormalSwitch) {
                slider.value = '0.1';
                document.getElementById('brushOpacityValue').textContent = '0.1';
                pendingOpacityNormalSwitch = false;
            }
        });
        
        document.getElementById('brushOpacity').addEventListener('touchend', (e) => {
            const slider = e.target;
            if (pendingOpacityFineSwitch) {
                slider.value = '0.09';
                document.getElementById('brushOpacityValue').textContent = '0.09 fine';
                pendingOpacityFineSwitch = false;
            } else if (pendingOpacityNormalSwitch) {
                slider.value = '0.1';
                document.getElementById('brushOpacityValue').textContent = '0.1';
                pendingOpacityNormalSwitch = false;
            }
        });
        document.getElementById('brushHardness').addEventListener('input', (e) => { 
            document.getElementById('brushHardnessValue').textContent = parseFloat(e.target.value).toFixed(1);
        });
        document.getElementById('brushSpacing').addEventListener('input', (e) => { 
            document.getElementById('brushSpacingValue').textContent = parseFloat(e.target.value).toFixed(1);
        });
        
        // Spacing label click to toggle mode
        document.getElementById('spacingLabel').addEventListener('click', () => {
            spacingSpeedMode = !spacingSpeedMode;
            const label = document.getElementById('spacingLabel');
            if (spacingSpeedMode) {
                label.textContent = 'Spacing (Absolute)';
            } else {
                label.textContent = 'Spacing (Smooth)';
            }
        });
        document.getElementById('brushFlow').addEventListener('input', (e) => { 
            document.getElementById('brushFlowValue').textContent = parseFloat(e.target.value).toFixed(1);
        });
        document.getElementById('brushScatter').addEventListener('input', (e) => { 
            document.getElementById('brushScatterValue').textContent = e.target.value;
        });
        document.getElementById('brushTaper').addEventListener('input', (e) => { 
            document.getElementById('brushTaperValue').textContent = parseFloat(e.target.value).toFixed(1);
        });
        document.getElementById('brushJitter').addEventListener('input', (e) => { 
            document.getElementById('brushJitterValue').textContent = parseFloat(e.target.value).toFixed(1);
        });
        
        // Rotation mode button listeners
        document.querySelectorAll('.rotation-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove active class from all buttons
                document.querySelectorAll('.rotation-mode-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                btn.classList.add('active');
                // Set rotation mode
                rotationMode = btn.dataset.mode;
                // Reset spin angle when changing modes
                spinAngle = 0;
            });
        });
        
        // Stabilisation controls
        document.getElementById('toggleStabilisation').addEventListener('click', (e) => {
            stabilisationEnabled = !stabilisationEnabled;
            e.target.textContent = stabilisationEnabled ? 'üéØ Disable Stabilisation' : 'üéØ Enable Stabilisation';
            document.getElementById('stabilisationStrengthLabel').style.display = stabilisationEnabled ? 'inline-block' : 'none';
        });
        
        document.getElementById('stabilisationStrength').addEventListener('input', (e) => {
            stabilisationStrength = parseInt(e.target.value) / 100; // Convert 0-100 to 0-1
            document.getElementById('stabilisationStrengthValue').textContent = e.target.value + '%';
        });

        // Stamp mode toggle
        document.getElementById('toggleStampMode').addEventListener('click', (e) => {
            if (!stampMode) {
                enterStampMode();
            } else {
                exitStampMode();
            }
        });

        document.getElementById('brushType').addEventListener('change', () => {
            const brushType = document.getElementById('brushType').value;
            
            // Enter pixel art mode when pixel brush is selected
            if (brushType === 'pixel' && !pixelArtMode) {
                // Block if timelapse challenge is active
                if (timelapseMode && strokesRemaining > 0) {
                    alert('‚ö†Ô∏è Pixel Art mode is not available during Timelapse Challenge. Please finish or reset the challenge first.');
                    return;
                }
                
                enterPixelArtMode();
                
                // Reset sliders to pixel art defaults
                document.getElementById('brushSize').value = 10;
                document.getElementById('brushOpacity').value = 1;
                document.getElementById('brushHardness').value = 1;
                document.getElementById('brushSpacing').value = 0.1;
                document.getElementById('brushFlow').value = 1;
                document.getElementById('brushScatter').value = 0;
                document.getElementById('brushTaper').value = 0;
                document.getElementById('brushJitter').value = 0;
            }
            // Exit pixel art mode when switching away from pixel brush
            else if (brushType !== 'pixel' && pixelArtMode) {
                exitPixelArtMode();
            }
            // Set scatter to 25% when oil brush is selected
            else if (brushType === 'oil') {
                document.getElementById('brushScatter').value = 15;
            }
            // Set defaults when texture brush is selected
            else if (brushType === 'texture') {
                // Set all slider values
                document.getElementById('brushSize').value = 30;
                document.getElementById('brushSizeValue').textContent = '30';
                
                // Set opacity to 0.4 (normal mode)
                const opacitySlider = document.getElementById('brushOpacity');
                const opacityValue = document.getElementById('brushOpacityValue');
                opacityFineMode = false;
                opacitySlider.min = '0.1';
                opacitySlider.max = '1';
                opacitySlider.step = '0.1';
                opacitySlider.classList.remove('opacity-fine-mode');
                opacitySlider.value = 0.4;
                opacityValue.textContent = '0.4';
                
                document.getElementById('brushHardness').value = 0.5;
                document.getElementById('brushHardnessValue').textContent = '0.5';
                document.getElementById('brushSpacing').value = 0.1;
                document.getElementById('brushSpacingValue').textContent = '0.1';
                document.getElementById('brushFlow').value = 1;
                document.getElementById('brushFlowValue').textContent = '1.0';
                document.getElementById('brushScatter').value = 0;
                document.getElementById('brushScatterValue').textContent = '0';
                document.getElementById('brushTaper').value = 0;
                document.getElementById('brushTaperValue').textContent = '0.0';
                document.getElementById('brushJitter').value = 0;
                document.getElementById('brushJitterValue').textContent = '0.0';
                
                // Set rotation mode to "fixed" (none)
                document.querySelectorAll('.rotation-mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                const fixedBtn = document.querySelector('.rotation-mode-btn[data-mode="none"]');
                if (fixedBtn) {
                    fixedBtn.classList.add('active');
                }
                rotationMode = 'none';
                
                // Enable stabilisation
                stabilisationEnabled = true;
                document.getElementById('toggleStabilisation').textContent = 'üéØ Disable Stabilisation';
                document.getElementById('stabilisationStrengthLabel').style.display = 'inline-block';
                
                updateCursor();
            }
            // Set opacity to 50% when render brush is selected
            else if (brushType === 'render') {
                document.getElementById('brushOpacity').value = 0.5;
                document.getElementById('brushOpacityValue').textContent = '0.5';
            }
            
            // Show/hide Load Texture button based on brush type
            const loadTextureBtn = document.getElementById('loadTexture');
            if (brushType === 'texture') {
                loadTextureBtn.style.display = 'block';
            } else {
                loadTextureBtn.style.display = 'none';
            }
            
            // Update controls title with current brush type
            const brushTypeNames = {
                'round': 'Round',
                'square': 'Square',
                'oil': 'Oil',
                'daub': 'Daub',
                'render': 'Render',
                'pixel': 'Pixel',
                'fill': 'Fill',
                'texture': 'Texture'
            };
            const brushTypeShortcuts = {
                'round': 'r',
                'square': 's',
                'oil': 'o',
                'daub': 'd',
                'render': 'e',
                'pixel': 'p',
                'fill': 'f',
                'texture': 'x'
            };
            document.getElementById('controlsTitle').textContent = `Brush Control for ${brushTypeNames[brushType] || brushType} (${brushTypeShortcuts[brushType] || ''})`;
            
            updateCursor(); // Update cursor when brush type changes
        });

        document.getElementById('enableDual').addEventListener('click', (e) => {
            dualBrushEnabled = !dualBrushEnabled;
            e.target.textContent = dualBrushEnabled ? 'Disable Dual Brush' : 'Enable Dual Brush';
            // Show secondary color selection modal when enabling dual brush
            if (dualBrushEnabled) {
                showSecondaryColorModal();
            }
        });

        document.getElementById('clearCanvas').addEventListener('click', () => {
            // Check if we need to reset timelapse challenge state
            if (drawingBlocked) {
                // Reset timelapse challenge
                timelapseMode = false;
                strokesRemaining = 30;
                drawingBlocked = false;
                
                // Hide challenge UI
                document.getElementById('timelapseChallenge').style.display = 'none';
                
                // Reset button text
                document.getElementById('startTimelapse').textContent = 'üé® Start Timelapse Challenge';
            }
            
            // Save state BEFORE clearing
            saveState();
            
            if (pixelArtMode) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = pixelArtWidth;
                tempCanvas.height = pixelArtHeight;
                const tempCtx = tempCanvas.getContext('2d');
                const imageData = tempCtx.createImageData(pixelArtWidth, pixelArtHeight);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255; data[i + 1] = 255; data[i + 2] = 255; data[i + 3] = 255;
                }
                frames[currentFrameIndex] = imageData;
            } else if (stampMode) {
                // Create black frame for stamp mode
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = stampWidth;
                tempCanvas.height = stampHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.fillStyle = 'black';
                tempCtx.fillRect(0, 0, stampWidth, stampHeight);
                const imageData = tempCtx.getImageData(0, 0, stampWidth, stampHeight);
                frames[currentFrameIndex] = imageData;
            } else {
                frames[currentFrameIndex] = createWhiteFrame();
            }
            switchFrame(currentFrameIndex, false); // Refresh view with onion skin
        });

        document.getElementById('eyedropper').addEventListener('click', () => {
            eyedropperMode = !eyedropperMode;
            if (eyedropperMode) {
                // Store current brush type before switching
                previousBrushType = document.getElementById('brushType').value;
                document.getElementById('eyedropper').textContent = 'üé® Eyedropper (Active)';
            } else {
                document.getElementById('eyedropper').textContent = 'üé® Eyedropper';
                // Restore previous brush type when manually disabling eyedropper
                document.getElementById('brushType').value = previousBrushType;
            }
            updateCursor();
        });

        document.getElementById('paletteUndoBtn').addEventListener('click', () => {
            undo();
        });

        document.getElementById('renderBtn').addEventListener('click', () => {
            // Save state BEFORE rendering
            saveState();
            
            const button = document.getElementById('renderBtn');
            button.disabled = true;
            button.textContent = '‚ú® RENDER';
            
            // Get current frame data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // Helper: Calculate luminance for edge detection
            function getLuminance(r, g, b) {
                return 0.299 * r + 0.587 * g + 0.114 * b;
            }
            
            // Helper: Get pixel index
            function getIndex(x, y) {
                return (y * width + x) * 4;
            }
            
            // Create a copy for reading original values
            const originalData = new Uint8ClampedArray(data);
            
            // Selective blur: Only blend similar colours, preserve high contrast edges
            const radius = 2; // Increased radius for stronger effect
            const contrastThreshold = 80; // Luminance difference to preserve edges
            
            // Progressive rendering variables
            let currentLine = 0;
            const linesPerFrame = 10; // Process 10 lines per animation frame
            
            function processNextBatch() {
                const endLine = Math.min(currentLine + linesPerFrame, height);
                
                // Process current batch of lines
                for (let py = currentLine; py < endLine; py++) {
                    for (let px = 0; px < width; px++) {
                        const idx = getIndex(px, py);
                        
                        // Skip transparent pixels
                        const alpha = originalData[idx + 3];
                        if (alpha < 10) continue;
                        
                        // Process ALL pixels for full-image blur (remove circular restriction)
                        const centerR = originalData[idx];
                        const centerG = originalData[idx + 1];
                        const centerB = originalData[idx + 2];
                        const centerLum = getLuminance(centerR, centerG, centerB);
                        
                        let sumR = 0, sumG = 0, sumB = 0, count = 0;
                        
                        // Sample neighboring pixels
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const nx = px + dx;
                                const ny = py + dy;
                                
                                // Boundary check
                                if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                                
                                const nIdx = getIndex(nx, ny);
                                const nAlpha = originalData[nIdx + 3];
                                
                                // Skip transparent pixels
                                if (nAlpha < 10) continue;
                                
                                const nR = originalData[nIdx];
                                const nG = originalData[nIdx + 1];
                                const nB = originalData[nIdx + 2];
                                const nLum = getLuminance(nR, nG, nB);
                                
                                // Only blend if luminance difference is below threshold (similar tones)
                                const lumDiff = Math.abs(centerLum - nLum);
                                if (lumDiff < contrastThreshold) {
                                    // Weight by distance (closer pixels have more influence)
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    const weight = 1 / (1 + distance);
                                    
                                    sumR += nR * weight;
                                    sumG += nG * weight;
                                    sumB += nB * weight;
                                    count += weight;
                                }
                            }
                        }
                        
                        // Apply blended color if we found similar neighbors
                        if (count > 0) {
                            // Mix 85% blended + 15% original for stronger effect
                            const blendedR = sumR / count;
                            const blendedG = sumG / count;
                            const blendedB = sumB / count;
                            
                            data[idx] = Math.round(blendedR * 0.85 + centerR * 0.15);
                            data[idx + 1] = Math.round(blendedG * 0.85 + centerG * 0.15);
                            data[idx + 2] = Math.round(blendedB * 0.85 + centerB * 0.15);
                        }
                    }
                }
                
                // Apply the processed area back to canvas
                ctx.putImageData(imageData, 0, 0);
                
                // Draw scan line effect (glowing blue line)
                ctx.save();
                ctx.strokeStyle = 'rgba(90, 159, 245, 0.8)';
                ctx.lineWidth = 2;
                ctx.shadowColor = 'rgba(90, 159, 245, 1)';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.moveTo(0, currentLine);
                ctx.lineTo(width, currentLine);
                ctx.stroke();
                ctx.restore();
                
                currentLine = endLine;
                
                // Continue processing or finish
                if (currentLine < height) {
                    requestAnimationFrame(processNextBatch);
                } else {
                    // Final render without scan line
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Save to current frame
                    frames[currentFrameIndex] = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    button.disabled = false;
                    button.textContent = '‚ú® Render';
                }
            }
            
            // Start progressive rendering
            processNextBatch();
        });


        document.getElementById('export').addEventListener('click', () => {
            const link = document.createElement('a');
            
            // Dynamic filename based on current mode
            if (stampMode) {
                link.download = 'stamp-01.png';
            } else if (pixelArtMode) {
                link.download = 'pixel-art-01.png';
            } else {
                link.download = 'brush-drawing-01.png';
            }
            
            if (pixelArtMode) {
                // Export at native pixel art resolution
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = pixelArtWidth;
                exportCanvas.height = pixelArtHeight;
                const exportCtx = exportCanvas.getContext('2d');
                exportCtx.putImageData(frames[currentFrameIndex], 0, 0);
                link.href = exportCanvas.toDataURL();
            } else {
                link.href = canvas.toDataURL();
            }
            
            link.click();
        });

        // Load PNG onto canvas
        document.getElementById('loadCanvas').addEventListener('click', () => {
            document.getElementById('canvasFileInput').click();
        });

        document.getElementById('canvasFileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    if (pixelArtMode) {
                        // Load into pixel art canvas
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = pixelArtWidth;
                        tempCanvas.height = pixelArtHeight;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0, pixelArtWidth, pixelArtHeight);
                        const imageData = tempCtx.getImageData(0, 0, pixelArtWidth, pixelArtHeight);
                        frames[currentFrameIndex] = imageData;
                        renderPixelArt();
                    } else if (stampMode) {
                        // Load into stamp canvas with resize and padding
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = stampWidth;
                        tempCanvas.height = stampHeight;
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        // Fill with black background
                        tempCtx.fillStyle = 'black';
                        tempCtx.fillRect(0, 0, stampWidth, stampHeight);
                        
                        // Calculate scaling - largest dimension should be 512
                        const scale = Math.min(stampWidth / img.width, stampHeight / img.height);
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        const offsetX = (stampWidth - scaledWidth) / 2;
                        const offsetY = (stampHeight - scaledHeight) / 2;
                        
                        // Draw centered and scaled
                        tempCtx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                        
                        // Convert to grayscale
                        let imageData = tempCtx.getImageData(0, 0, stampWidth, stampHeight);
                        imageData = convertToGrayscale(imageData);
                        
                        frames[currentFrameIndex] = imageData;
                        ctx.putImageData(imageData, 0, 0);
                    } else {
                        // Load into regular canvas
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    }
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            
            // Reset file input so same file can be loaded again
            e.target.value = '';
        });

        // Export Brush as .jbrush
        document.getElementById('exportBrush').addEventListener('click', () => {
            // Get current brush type from dropdown (most reliable source)
            const currentBrushType = document.getElementById('brushType').value;
            const brushName = prompt('Enter brush name:', `${currentBrushType}_brush`);
            if (!brushName) return;
            
            const brushData = {
                name: brushName,
                version: "1.0",
                author: "Unknown",
                created: new Date().toISOString().split('T')[0],
                brush: {
                    type: currentBrushType,
                    size: parseInt(document.getElementById('brushSize').value),
                    opacity: parseFloat(document.getElementById('brushOpacity').value),
                    hardness: parseFloat(document.getElementById('brushHardness').value),
                    color: primaryBrush.color,
                    spacing: parseFloat(document.getElementById('brushSpacing').value),
                    flow: parseFloat(document.getElementById('brushFlow').value),
                    scatter: parseInt(document.getElementById('brushScatter').value),
                    taper: parseFloat(document.getElementById('brushTaper').value),
                    jitter: parseFloat(document.getElementById('brushJitter').value),
                    rotationMode: rotationMode,
                    spinAngle: spinAngle
                },
                metadata: {
                    tags: [currentBrushType, "custom"],
                    app: "Timelapse Brush Simulator",
                    appVersion: "0.1"
                }
            };
            
            const json = JSON.stringify(brushData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.download = `${brushName}.jbrush`;
            link.href = url;
            link.click();
            
            URL.revokeObjectURL(url);
        });

        // Brush slot click handlers
        document.querySelectorAll('.brush-slot').forEach(button => {
            button.addEventListener('click', (e) => {
                const slotNum = parseInt(e.target.dataset.slot) - 1;
                const slotData = brushSlots[slotNum];
                
                if (slotData.brush) {
                    // Load brush from slot
                    const brush = slotData.brush;
                    primaryBrush.type = brush.type;
                    primaryBrush.size = brush.size;
                    primaryBrush.opacity = brush.opacity;
                    primaryBrush.hardness = brush.hardness;
                    primaryBrush.color = brush.color;
                    primaryBrush.spacing = brush.spacing;
                    primaryBrush.flow = brush.flow;
                    primaryBrush.scatter = brush.scatter;
                    primaryBrush.taper = brush.taper;
                    primaryBrush.jitter = brush.jitter;
                    
                    // Set rotation mode and spin angle if available (backward compatibility)
                    if (brush.rotationMode !== undefined) {
                        rotationMode = brush.rotationMode;
                        // Update rotation mode buttons
                        document.querySelectorAll('.rotation-mode-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        const activeBtn = document.querySelector(`.rotation-mode-btn[data-mode="${rotationMode}"]`);
                        if (activeBtn) {
                            activeBtn.classList.add('active');
                        }
                    }
                    if (brush.spinAngle !== undefined) {
                        spinAngle = brush.spinAngle;
                    }
                    
                    // Update UI
                    document.getElementById('brushType').value = primaryBrush.type;
                    document.getElementById('brushSize').value = primaryBrush.size;
                    
                    // Handle opacity - check if we need to enter fine mode
                    const opacitySlider = document.getElementById('brushOpacity');
                    const opacityValue = document.getElementById('brushOpacityValue');
                    if (primaryBrush.opacity < 0.1) {
                        // Switch to fine mode first
                        opacityFineMode = true;
                        opacitySlider.min = '0';
                        opacitySlider.max = '0.1';
                        opacitySlider.step = '0.01';
                        opacitySlider.classList.add('opacity-fine-mode');
                        opacitySlider.value = primaryBrush.opacity;
                        opacityValue.textContent = primaryBrush.opacity.toFixed(2) + ' fine';
                    } else {
                        // Normal mode
                        opacityFineMode = false;
                        opacitySlider.min = '0.1';
                        opacitySlider.max = '1';
                        opacitySlider.step = '0.1';
                        opacitySlider.classList.remove('opacity-fine-mode');
                        opacitySlider.value = primaryBrush.opacity;
                        opacityValue.textContent = primaryBrush.opacity.toFixed(1);
                    }
                    
                    document.getElementById('brushHardness').value = primaryBrush.hardness;
                    document.getElementById('brushSpacing').value = primaryBrush.spacing;
                    document.getElementById('brushFlow').value = primaryBrush.flow;
                    document.getElementById('brushScatter').value = primaryBrush.scatter;
                    document.getElementById('brushTaper').value = primaryBrush.taper;
                    document.getElementById('brushJitter').value = primaryBrush.jitter;
                    
                    // Update all value displays
                    document.getElementById('brushSizeValue').textContent = primaryBrush.size;
                    document.getElementById('brushHardnessValue').textContent = primaryBrush.hardness.toFixed(1);
                    document.getElementById('brushSpacingValue').textContent = primaryBrush.spacing.toFixed(1);
                    document.getElementById('brushFlowValue').textContent = primaryBrush.flow.toFixed(1);
                    document.getElementById('brushScatterValue').textContent = primaryBrush.scatter;
                    document.getElementById('brushTaperValue').textContent = primaryBrush.taper.toFixed(1);
                    document.getElementById('brushJitterValue').textContent = primaryBrush.jitter.toFixed(1);
                    
                    document.getElementById('brushType').dispatchEvent(new Event('change'));
                    updateCursor();
                } else {
                    // Empty slot: trigger import directly to this slot
                    selectedSlot = slotNum;
                    document.getElementById('brushFileInput').click();
                }
            });
        });

        // Update slot modal display based on filled slots
        function updateSlotModal() {
            const modalButtons = document.querySelectorAll('.slot-select-btn');
            modalButtons.forEach((btn, index) => {
                const slotData = brushSlots[index];
                if (slotData.brush) {
                    btn.classList.add('filled');
                    btn.innerHTML = `Slot ${index + 1}<br><small>${slotData.name || 'Custom'}</small>`;
                } else {
                    btn.classList.remove('filled');
                    btn.innerHTML = `Slot ${index + 1}<br><small>(Empty)</small>`;
                }
            });
        }

        // Import Brush from .jbrush
        document.getElementById('importBrush').addEventListener('click', () => {
            updateSlotModal();
            document.getElementById('slotModal').style.display = 'flex';
        });
        
        // Slot selection in modal
        document.querySelectorAll('.slot-select-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const slotNum = parseInt(btn.dataset.slot) - 1;
                selectedSlot = slotNum;
                document.getElementById('slotModal').style.display = 'none';
                document.getElementById('brushFileInput').click();
            });
        });
        
        // Cancel modal
        document.getElementById('slotModalCancel').addEventListener('click', () => {
            document.getElementById('slotModal').style.display = 'none';
            selectedSlot = null;
        });
        
        // Close modal on background click
        document.getElementById('slotModal').addEventListener('click', (e) => {
            if (e.target.id === 'slotModal') {
                document.getElementById('slotModal').style.display = 'none';
                selectedSlot = null;
            }
        });

        // Secondary Color Modal functions
        function showSecondaryColorModal() {
            const modal = document.getElementById('secondaryColorModal');
            const swatchesContainer = document.getElementById('secondaryColorSwatches');
            
            // Clear existing swatches
            swatchesContainer.innerHTML = '';
            
            // Add color swatches from current palette
            colorPalette.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.title = color;
                swatch.style.width = '40px';
                swatch.style.height = '40px';
                
                swatch.addEventListener('click', () => {
                    secondaryBrush.color = color;
                    modal.style.display = 'none';
                });
                
                swatchesContainer.appendChild(swatch);
            });
            
            modal.style.display = 'flex';
        }

        // Secondary color modal cancel button
        document.getElementById('secondaryColorCancel').addEventListener('click', () => {
            document.getElementById('secondaryColorModal').style.display = 'none';
            // If user cancels, disable dual brush
            dualBrushEnabled = false;
            document.getElementById('enableDual').textContent = 'Enable Dual Brush';
        });

        // Close secondary color modal on background click
        document.getElementById('secondaryColorModal').addEventListener('click', (e) => {
            if (e.target.id === 'secondaryColorModal') {
                document.getElementById('secondaryColorModal').style.display = 'none';
                // If user cancels, disable dual brush
                dualBrushEnabled = false;
                document.getElementById('enableDual').textContent = 'Enable Dual Brush';
            }
        });

        document.getElementById('brushFileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            if (selectedSlot === null) {
                alert('‚ùå No slot selected.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const brushData = JSON.parse(event.target.result);
                    
                    // Validate brush data
                    if (!brushData.brush) {
                        alert('‚ùå Invalid brush file: missing brush data');
                        return;
                    }
                    
                    // Save to selected slot
                    brushSlots[selectedSlot] = brushData;
                    
                    // Update slot button to show it's filled (darker green gradient)
                    const slotButton = document.getElementById('brushSlot' + (selectedSlot + 1));
                    slotButton.style.background = 'linear-gradient(135deg, #3cb371 0%, #2e8b57 100%)';
                    slotButton.style.color = '#ffffff';
                    slotButton.title = brushData.name || 'Custom Brush';
                    
                    // Activate the imported brush immediately
                    const brush = brushData.brush;
                    primaryBrush.type = brush.type;
                    primaryBrush.size = brush.size;
                    primaryBrush.opacity = brush.opacity;
                    primaryBrush.hardness = brush.hardness;
                    primaryBrush.color = brush.color;
                    primaryBrush.spacing = brush.spacing;
                    primaryBrush.flow = brush.flow;
                    primaryBrush.scatter = brush.scatter;
                    primaryBrush.taper = brush.taper;
                    primaryBrush.jitter = brush.jitter;
                    
                    // Set rotation mode and spin angle if available (backward compatibility)
                    if (brush.rotationMode !== undefined) {
                        rotationMode = brush.rotationMode;
                        // Update rotation mode buttons
                        document.querySelectorAll('.rotation-mode-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        const activeBtn = document.querySelector(`.rotation-mode-btn[data-mode="${rotationMode}"]`);
                        if (activeBtn) {
                            activeBtn.classList.add('active');
                        }
                    }
                    if (brush.spinAngle !== undefined) {
                        spinAngle = brush.spinAngle;
                    }
                    
                    // Update UI
                    document.getElementById('brushType').value = primaryBrush.type;
                    document.getElementById('brushSize').value = primaryBrush.size;
                    
                    // Handle opacity - check if we need to enter fine mode
                    const opacitySlider = document.getElementById('brushOpacity');
                    const opacityValue = document.getElementById('brushOpacityValue');
                    if (primaryBrush.opacity < 0.1) {
                        // Switch to fine mode first
                        opacityFineMode = true;
                        opacitySlider.min = '0';
                        opacitySlider.max = '0.1';
                        opacitySlider.step = '0.01';
                        opacitySlider.classList.add('opacity-fine-mode');
                        opacitySlider.value = primaryBrush.opacity;
                        opacityValue.textContent = primaryBrush.opacity.toFixed(2) + ' fine';
                    } else {
                        // Normal mode
                        opacityFineMode = false;
                        opacitySlider.min = '0.1';
                        opacitySlider.max = '1';
                        opacitySlider.step = '0.1';
                        opacitySlider.classList.remove('opacity-fine-mode');
                        opacitySlider.value = primaryBrush.opacity;
                        opacityValue.textContent = primaryBrush.opacity.toFixed(1);
                    }
                    
                    document.getElementById('brushHardness').value = primaryBrush.hardness;
                    document.getElementById('brushSpacing').value = primaryBrush.spacing;
                    document.getElementById('brushFlow').value = primaryBrush.flow;
                    document.getElementById('brushScatter').value = primaryBrush.scatter;
                    document.getElementById('brushTaper').value = primaryBrush.taper;
                    document.getElementById('brushJitter').value = primaryBrush.jitter;
                    
                    // Update all value displays
                    document.getElementById('brushSizeValue').textContent = primaryBrush.size;
                    document.getElementById('brushHardnessValue').textContent = primaryBrush.hardness.toFixed(1);
                    document.getElementById('brushSpacingValue').textContent = primaryBrush.spacing.toFixed(1);
                    document.getElementById('brushFlowValue').textContent = primaryBrush.flow.toFixed(1);
                    document.getElementById('brushScatterValue').textContent = primaryBrush.scatter;
                    document.getElementById('brushTaperValue').textContent = primaryBrush.taper.toFixed(1);
                    document.getElementById('brushJitterValue').textContent = primaryBrush.jitter.toFixed(1);
                    
                    document.getElementById('brushType').dispatchEvent(new Event('change'));
                    updateCursor();
                    
                    const name = brushData.name || 'Custom Brush';
                    alert(`‚úÖ Saved "${name}" to slot ${selectedSlot + 1}`);
                    
                    selectedSlot = null;
                } catch (error) {
                    alert('‚ùå Error loading brush file: ' + error.message);
                    selectedSlot = null;
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            e.target.value = '';
        });

        // Load Texture button
        document.getElementById('loadTexture').addEventListener('click', (e) => {
            e.preventDefault();
            const tips = `üìã TEXTURE LOADING TIPS:\n\n` +
                `‚úì Use black and white images only\n` +
                `‚úì Black areas will be converted to transparent\n` +
                `‚úì White/gray areas will become the brush shape\n` +
                `‚úì Recommended size: 256√ó256 or 512√ó512 pixels\n` +
                `‚úì Supported formats: PNG, JPG\n\n` +
                `Ready to load a texture?`;
            
            if (confirm(tips)) {
                // Use setTimeout to preserve user gesture for file picker
                setTimeout(() => {
                    document.getElementById('textureFileInput').click();
                }, 0);
            }
        });

        // Texture file input handler
        document.getElementById('textureFileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            // Validate file type
            if (!file.type.match('image/(png|jpeg|jpg)')) {
                alert('‚ùå Please select a PNG or JPG image file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    // Validate texture size (warn if too large)
                    if (img.width > 1024 || img.height > 1024) {
                        const proceed = confirm(`‚ö†Ô∏è Texture is ${img.width}√ó${img.height}. Large textures may impact performance. Recommended: 256√ó256 or 512√ó512.\n\nContinue anyway?`);
                        if (!proceed) {
                            e.target.value = '';
                            return;
                        }
                    }
                    
                    // Convert black pixels to transparent
                    const processCanvas = document.createElement('canvas');
                    processCanvas.width = img.width;
                    processCanvas.height = img.height;
                    const processCtx = processCanvas.getContext('2d');
                    processCtx.drawImage(img, 0, 0);
                    
                    const imageData = processCtx.getImageData(0, 0, img.width, img.height);
                    const data = imageData.data;
                    
                    // Convert grayscale to alpha transparency
                    // Black (0) = fully transparent, White (255) = fully opaque
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // Calculate grayscale value (luminance)
                        const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                        
                        // Use grayscale value as alpha channel
                        // White areas = opaque (255), Black areas = transparent (0)
                        data[i + 3] = gray;
                        
                        // Set RGB to white so texture takes on brush color
                        data[i] = 255;
                        data[i + 1] = 255;
                        data[i + 2] = 255;
                    }
                    
                    processCtx.putImageData(imageData, 0, 0);
                    
                    // Create new image from processed canvas
                    const processedImg = new Image();
                    processedImg.onload = () => {
                        brushTexture = processedImg;
                        textureLoaded = true;
                        console.log(`Texture loaded and processed: ${img.width}√ó${img.height}`);
                        alert(`‚úÖ Texture loaded successfully!\nSize: ${img.width}√ó${img.height}px\nBlack pixels converted to transparent.`);
                        
                        // Update cursor to reflect new texture
                        updateCursor();
                    };
                    processedImg.src = processCanvas.toDataURL();
                };
                img.onerror = () => {
                    alert('‚ùå Failed to load texture image.');
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            
            // Reset file input
            e.target.value = '';
        });

        // Animation
        document.getElementById('addFrame').addEventListener('click', () => {
            // Create a new white frame at appropriate resolution
            let whiteFrame;
            if (pixelArtMode) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = pixelArtWidth;
                tempCanvas.height = pixelArtHeight;
                const tempCtx = tempCanvas.getContext('2d');
                const imageData = tempCtx.createImageData(pixelArtWidth, pixelArtHeight);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255; data[i + 1] = 255; data[i + 2] = 255; data[i + 3] = 255;
                }
                whiteFrame = imageData;
            } else {
                whiteFrame = createWhiteFrame();
            }
            frames.push(whiteFrame);
            
            // Switch to the new white frame
            switchFrame(frames.length - 1, false);
        });

        document.getElementById('frameSlider').addEventListener('input', (e) => {
            switchFrame(parseInt(e.target.value) - 1);
        });

        document.getElementById('playAnimation').addEventListener('click', () => {
            if (isPlaying) {
                clearInterval(animationInterval);
                isPlaying = false;
                document.getElementById('playAnimation').textContent = 'Play';
                return;
            }
            isPlaying = true;
            document.getElementById('playAnimation').textContent = 'Stop';
            animationInterval = setInterval(() => {
                currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                switchFrame(currentFrameIndex, false);
            }, 100); // 10 FPS for smoother animation
        });

        document.getElementById('toggleOnion').addEventListener('click', (e) => {
            onionSkin = !onionSkin;
            e.target.textContent = onionSkin ? 'Disable Onion Skin' : 'Enable Onion Skin';
            switchFrame(currentFrameIndex, false); // Refresh view
        });

        document.getElementById('exportGif').addEventListener('click', () => {
            const button = document.getElementById('exportGif');
            button.disabled = true;
            button.textContent = 'Generating GIF...';
            
            // Convert frames to image array
            const images = [];
            for (let i = 0; i < frames.length; i++) {
                // Create a temporary canvas for each frame
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(frames[i], 0, 0);
                images.push(tempCanvas.toDataURL('image/png'));
            }
            
            // Create GIF using gifshot
            gifshot.createGIF({
                images: images,
                gifWidth: canvas.width,
                gifHeight: canvas.height,
                interval: 0.1, // 0.1 seconds = 100ms between frames
                numFrames: frames.length,
                frameDuration: 2, // 2 = ~100ms per frame (10 FPS)
                sampleInterval: 10,
                numWorkers: 2
            }, (obj) => {
                if (!obj.error) {
                    const link = document.createElement('a');
                    link.download = 'animation.gif';
                    link.href = obj.image;
                    link.click();
                    
                    button.disabled = false;
                    button.textContent = 'Export GIF';
                } else {
                    alert('Error creating GIF: ' + obj.error);
                    button.disabled = false;
                    button.textContent = 'Export GIF';
                }
            });
        });

        // Timelapse Challenge handlers
        document.getElementById('startTimelapse').addEventListener('click', () => {
            // Block if in pixel art mode
            if (pixelArtMode) {
                alert('‚ö†Ô∏è Timelapse Challenge is not available in Pixel Art mode. Please switch to a different brush first.');
                return;
            }
            
            if (confirm('Start Timelapse Challenge? You will have 30 strokes to create your artwork, and each stroke will be captured for a timelapse GIF.')) {
                // Reset state
                timelapseMode = true;
                strokesRemaining = 30;
                timelapseSnapshots = [];
                drawingBlocked = false;
                
                // Clear canvas
                frames[currentFrameIndex] = createWhiteFrame();
                switchFrame(currentFrameIndex, false);
                
                // Show challenge UI
                document.getElementById('timelapseChallenge').style.display = 'block';
                document.getElementById('strokeCount').textContent = '30';
                document.getElementById('exportTimelapse').disabled = true;
                document.getElementById('startTimelapse').textContent = 'Reset Challenge';
            }
        });

        document.getElementById('exportTimelapse').addEventListener('click', () => {
            const button = document.getElementById('exportTimelapse');
            button.disabled = true;
            button.textContent = 'Generating Timelapse...';
            
            // Create GIF from snapshots
            gifshot.createGIF({
                images: timelapseSnapshots,
                gifWidth: canvas.width,
                gifHeight: canvas.height,
                interval: 0.15, // 150ms per frame for timelapse
                numFrames: timelapseSnapshots.length,
                frameDuration: 3, // ~150ms per frame
                sampleInterval: 10,
                numWorkers: 2
            }, (obj) => {
                if (!obj.error) {
                    const link = document.createElement('a');
                    link.download = 'timelapse.gif';
                    link.href = obj.image;
                    link.click();
                    
                    button.disabled = false;
                    button.textContent = 'Export Timelapse';
                } else {
                    alert('Error creating timelapse: ' + obj.error);
                    button.disabled = false;
                    button.textContent = 'Export Timelapse';
                }
            });
        });

        // Helper to convert RGB to hex
        function rgbToHex(rgb) {
            const match = rgb.match(/\d+/g);
            if (!match) return rgb;
            const r = parseInt(match[0]);
            const g = parseInt(match[1]);
            const b = parseInt(match[2]);
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // Palette detach/dock system
        function detachPalette() {
            const palette = document.getElementById('colorPalette');
            const container = document.getElementById('paletteContainer');
            
            if (!paletteFloating) {
                // Check if landscape orientation (wider than tall)
                const isLandscape = window.innerWidth > window.innerHeight;
                
                // Trigger pink glow and tilt on canvas FIRST
                const canvas = document.getElementById('canvas');
                canvas.classList.add('glow-pulse');
                
                // Auto-scroll to show button row at top with buffer
                const buttonRow = document.getElementById('buttonRow');
                if (buttonRow) {
                    buttonRow.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => {
                        window.scrollBy({ top: -20, behavior: 'smooth' });
                    }, 300);
                }
                
                // Wait 150ms for glow/tilt animation, THEN undock and reposition
                setTimeout(() => {
                    canvas.classList.remove('glow-pulse');
                    
                    // Detach: make floating and start in vertical mode
                    paletteOriginalParent = container;
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    palette.classList.add('floating');
                    palette.classList.add('vertical');
                    document.body.appendChild(palette);
                    
                    // Auto-position to left side of canvas
                    const paletteWidth = palette.offsetWidth;
                    palette.style.left = (canvasRect.left - paletteWidth - 20) + 'px';
                    palette.style.top = '20px';
                    palette.style.right = 'auto';
                    
                    paletteFloating = true;
                    document.getElementById('paletteDetachBtn').textContent = 'üîí';
                    document.getElementById('paletteDetachBtn').title = 'Dock Palette';
                    
                    // Also detach controls if landscape and not already floating
                    if (isLandscape && !controlsFloating) {
                        detachControls();
                    }
                    
                    updatePinIconText();
                }, 150);
            } else {
                // Dock: return to original position
                dockPalette();
            }
        }
        
        function dockPalette() {
            const palette = document.getElementById('colorPalette');
            
            palette.classList.remove('floating');
            palette.classList.remove('vertical');
            palette.style.left = '';
            palette.style.top = '';
            palette.style.transform = '';
            
            if (paletteOriginalParent) {
                paletteOriginalParent.insertBefore(palette, paletteOriginalParent.firstChild);
            }
            
            paletteFloating = false;
            paletteDragging = false;
            document.getElementById('paletteDetachBtn').textContent = 'üìå';
            document.getElementById('paletteDetachBtn').title = 'Detach Palette';
            
            updatePinIconText();
        }
        
        function checkPaletteDocking(x, y) {
            if (!paletteFloating) return;
            
            const container = document.getElementById('paletteContainer');
            const rect = container.getBoundingClientRect();
            
            // Check if palette is near its original position (within 50px)
            const distance = Math.sqrt(
                Math.pow(x - rect.left, 2) + 
                Math.pow(y - rect.top, 2)
            );
            
            if (distance < 50) {
                dockPalette();
            }
        }

        // Brush controls detach/dock functions
        function detachControls() {
            const controls = document.getElementById('brushControls');
            const container = document.getElementById('brushControlsContainer');
            
            if (!controlsFloating) {
                // Check if landscape orientation (wider than tall)
                const isLandscape = window.innerWidth > window.innerHeight;
                
                // Trigger pink glow and tilt on canvas FIRST
                const canvas = document.getElementById('canvas');
                canvas.classList.add('glow-pulse');
                
                // Auto-scroll to show button row at top with buffer
                const buttonRow = document.getElementById('buttonRow');
                if (buttonRow) {
                    buttonRow.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setTimeout(() => {
                        window.scrollBy({ top: -20, behavior: 'smooth' });
                    }, 300);
                }
                
                // Wait 150ms for glow/tilt animation, THEN undock and reposition
                setTimeout(() => {
                    canvas.classList.remove('glow-pulse');
                    
                    // Detach: make floating and start in vertical mode
                    controlsOriginalParent = container;
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    controls.classList.add('floating');
                    controls.classList.add('vertical');
                    document.body.appendChild(controls);
                    
                    // Auto-position to right side of canvas
                    controls.style.left = (canvasRect.right + 20) + 'px';
                    controls.style.top = '20px';
                    controls.style.right = 'auto';
                    
                    controlsFloating = true;
                    document.getElementById('controlsDetachBtn').textContent = 'üîí';
                    document.getElementById('controlsDetachBtn').title = 'Dock Controls';
                    
                    // Also detach palette if landscape and not already floating
                    if (isLandscape && !paletteFloating) {
                        detachPalette();
                    }
                    
                    updatePinIconText();
                }, 150);
            } else {
                // Dock: return to original position
                dockControls();
            }
        }
        
        function dockControls() {
            const controls = document.getElementById('brushControls');
            
            controls.classList.remove('floating');
            controls.classList.remove('vertical');
            controls.style.left = '';
            controls.style.top = '';
            controls.style.transform = '';
            
            if (controlsOriginalParent) {
                controlsOriginalParent.appendChild(controls);
            }
            
            controlsFloating = false;
            controlsDragging = false;
            document.getElementById('controlsDetachBtn').textContent = 'üìå';
            document.getElementById('controlsDetachBtn').title = 'Detach Controls';
            
            updatePinIconText();
        }
        
        function checkControlsDocking(x, y) {
            if (!controlsFloating) return;
            
            const container = document.getElementById('brushControlsContainer');
            const rect = container.getBoundingClientRect();
            
            // Check if controls are near original position (within 50px)
            const distance = Math.sqrt(
                Math.pow(x - rect.left, 2) + 
                Math.pow(y - rect.top, 2)
            );
            
            if (distance < 50) {
                dockControls();
            }
        }

        // Track scroll position for direction detection
        let lastScrollY = window.scrollY;

        // Check if animation controls are visible and auto-dock if scrolled away
        function checkCanvasVisibility() {
            const animationControls = document.querySelector('.animation-controls');
            const rect = animationControls.getBoundingClientRect();
            const currentScrollY = window.scrollY;
            
            // Check if scrolling down (currentScrollY > lastScrollY)
            const isScrollingDown = currentScrollY > lastScrollY;
            
            // Check if animation controls scrolled above viewport (bottom edge is above screen top)
            const isScrolledAboveViewport = rect.bottom < 0;
            
            // Only dock if scrolling down AND animation controls have scrolled above viewport
            if (isScrollingDown && isScrolledAboveViewport) {
                if (paletteFloating) {
                    dockPalette();
                }
                if (controlsFloating) {
                    dockControls();
                }
            }
            
            // Update last scroll position
            lastScrollY = currentScrollY;
        }

        // Add scroll listener to check animation controls visibility
        window.addEventListener('scroll', checkCanvasVisibility);

        // Intersection Observer for Project Overview section
        function setupProjectOverviewObserver() {
            // Find the Project Overview section by looking for its h3 heading
            const sections = document.querySelectorAll('section');
            let projectOverviewSection = null;
            
            sections.forEach(section => {
                const heading = section.querySelector('h3');
                if (heading && heading.textContent.includes('Project Overview')) {
                    projectOverviewSection = section;
                }
            });
            
            if (!projectOverviewSection) return;
            
            // Create Intersection Observer
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    // When Project Overview section comes into view (is intersecting)
                    if (entry.isIntersecting) {
                        // Check if any boxes are undocked before doing anything
                        const anyUndocked = paletteFloating || controlsFloating;
                        
                        // Dock both palette and controls if they're floating
                        if (paletteFloating) {
                            dockPalette();
                        }
                        if (controlsFloating) {
                            dockControls();
                        }
                        
                        // Only auto-scroll if any boxes were undocked
                        if (anyUndocked) {
                            // Auto-scroll to show Technical Documentation heading at top
                            // Find the parent div containing the h2 "Technical Documentation"
                            const techDocSection = projectOverviewSection.closest('div');
                            if (techDocSection) {
                                // Small delay to ensure docking animations complete
                                setTimeout(() => {
                                    techDocSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }, 200);
                            }
                        }
                    }
                });
            }, {
                threshold: 0.1, // Trigger when 10% of the section is visible
                rootMargin: '0px'
            });
            
            // Start observing the Project Overview section
            observer.observe(projectOverviewSection);
        }

        // Initialize Project Overview observer after page loads
        window.addEventListener('load', setupProjectOverviewObserver);

        // Auto-detach palette and controls on landscape screens
        function autoDetachForLandscape() {
            const isLandscape = window.innerWidth > window.innerHeight;
            if (isLandscape) {
                detachPalette();
                detachControls();
                updatePinIconText();
            }
        }

        // Update pin icon text based on current layout state
        function updatePinIconText() {
            const pinIcon = document.getElementById('introPinIcon');
            if (paletteFloating || controlsFloating) {
                pinIcon.textContent = 'click (üìå) to DOCK layout.';
            } else {
                pinIcon.textContent = 'click (üìå) to UNDOCK layout.';
            }
        }

        // Initialize auto-detach for landscape screens
        window.addEventListener('load', autoDetachForLandscape);
        window.addEventListener('load', updatePinIconText);

        // Palette switching debounce state
        let paletteSwitchTimeout = null;
        let isPaletteSwitching = false;

        // Initialize colour palette
        function initColorPalette() {
            const swatchesContainer = document.getElementById('paletteSwatches');
            const paletteContainer = document.getElementById('colorPalette');
            
            // Clear existing swatches
            swatchesContainer.innerHTML = '';
            
            // Update or create palette name label
            let paletteName = paletteContainer.querySelector('.palette-name');
            if (!paletteName) {
                paletteName = document.createElement('div');
                paletteName.className = 'palette-name';
                paletteContainer.insertBefore(paletteName, paletteContainer.firstChild.nextSibling);
            }
            
            paletteName.textContent = palettes[currentPaletteIndex].name;
            paletteName.title = 'Click to switch palette';
            paletteName.addEventListener('click', () => {
                // Debounce palette switching to prevent lock-ups from rapid clicks
                if (isPaletteSwitching) return;
                
                isPaletteSwitching = true;
                
                // Clear any pending timeout
                if (paletteSwitchTimeout) {
                    clearTimeout(paletteSwitchTimeout);
                }
                
                // Cycle to next palette
                currentPaletteIndex = (currentPaletteIndex + 1) % palettes.length;
                colorPalette = palettes[currentPaletteIndex].colors;
                
                // Use requestAnimationFrame for smoother UI updates
                requestAnimationFrame(() => {
                    initColorPalette();
                    
                    // Update current brush colour to first colour of new palette
                    primaryBrush.color = colorPalette[10]; // Default to middle colour
                    
                    // Re-enable switching after a short delay
                    paletteSwitchTimeout = setTimeout(() => {
                        isPaletteSwitching = false;
                    }, 150); // 150ms debounce
                });
            });
            
            // Update selector buttons to show active palette
            const selectorButtons = document.querySelectorAll('.palette-selector-btn');
            selectorButtons.forEach((btn, index) => {
                if (index === currentPaletteIndex) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Add colour swatches
            colorPalette.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.title = color;
                if (index === 10) swatch.classList.add('selected'); // Default to middle color
                
                swatch.addEventListener('click', () => {
                    // Remove previous selection
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                    
                    // Update brush colour
                    primaryBrush.color = color;
                });
                
                swatchesContainer.appendChild(swatch);
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            // Ctrl+Z for undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y or Ctrl+Shift+Z for redo
            else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
            // Brush shortcuts (only when not holding Ctrl/Cmd)
            else if (!e.ctrlKey && !e.metaKey && !e.altKey) {
                const key = e.key.toLowerCase();
                const brushSelect = document.getElementById('brushType');
                let brushChanged = false;
                
                // Palette shortcuts 1-9
                if (key >= '1' && key <= '9') {
                    const paletteIndex = parseInt(key) - 1;
                    if (paletteIndex < palettes.length) {
                        e.preventDefault();
                        currentPaletteIndex = paletteIndex;
                        colorPalette = palettes[currentPaletteIndex].colors;
                        initColorPalette();
                        return;
                    }
                }
                
                switch(key) {
                    case 'r':
                        brushSelect.value = 'round';
                        brushChanged = true;
                        break;
                    case 's':
                        brushSelect.value = 'square';
                        brushChanged = true;
                        break;
                    case 't':
                        brushSelect.value = 'texture';
                        brushChanged = true;
                        break;
                    case 'o':
                        brushSelect.value = 'oil';
                        brushChanged = true;
                        break;
                    case 'd':
                        brushSelect.value = 'daub';
                        brushChanged = true;
                        break;
                    case 'e':
                        brushSelect.value = 'render';
                        brushChanged = true;
                        break;
                    case 'p':
                        brushSelect.value = 'pixel';
                        brushChanged = true;
                        break;
                    case 'f':
                        brushSelect.value = 'fill';
                        brushChanged = true;
                        break;
                }
                
                // Trigger the change event to apply brush-specific settings
                if (brushChanged) {
                    e.preventDefault();
                    brushSelect.dispatchEvent(new Event('change'));
                    updateActiveBrushDisplay();
                }
                
                // Brush size shortcuts [ and ]
                if (key === '[') {
                    e.preventDefault();
                    const sizeSlider = document.getElementById('brushSize');
                    const currentSize = parseInt(sizeSlider.value);
                    sizeSlider.value = Math.max(1, currentSize - 2);
                    updateCursor();
                } else if (key === ']') {
                    e.preventDefault();
                    const sizeSlider = document.getElementById('brushSize');
                    const currentSize = parseInt(sizeSlider.value);
                    sizeSlider.value = Math.min(50, currentSize + 2);
                    updateCursor();
                }
            }
        });

        // Initialize
        initColorPalette();
        updateFrameDisplay();
        switchFrame(0);
        document.getElementById('toggleOnion').textContent = onionSkin ? 'Disable Onion Skin' : 'Enable Onion Skin';
        updateCursor(); // Set initial cursor
        
        // Apply default brush settings on page load
        document.getElementById('brushType').dispatchEvent(new Event('change'));
        
        // Palette selector buttons
        document.querySelectorAll('.palette-selector-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const paletteIndex = parseInt(btn.dataset.palette);
                if (paletteIndex < palettes.length) {
                    currentPaletteIndex = paletteIndex;
                    colorPalette = palettes[currentPaletteIndex].colors;
                    initColorPalette();
                    primaryBrush.color = colorPalette[10];
                }
            });
        });
        
        // Palette detach button
        document.getElementById('paletteDetachBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            detachPalette();
        });
        
        // Palette rotate button
        document.getElementById('paletteRotateBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const palette = document.getElementById('colorPalette');
            palette.classList.toggle('vertical');
        });
        
        // Palette dragging
        document.getElementById('colorPalette').addEventListener('mousedown', (e) => {
            const palette = document.getElementById('colorPalette');
            if (!paletteFloating) return;
            if (e.target.classList.contains('color-swatch')) return;
            if (e.target.classList.contains('palette-name')) return;
            if (e.target.classList.contains('palette-selector-btn')) return;
            if (e.target.id === 'paletteDetachBtn') return;
            if (e.target.id === 'paletteRotateBtn') return;
            if (e.target.id === 'brushType') return;
            if (e.target.id === 'eyedropper') return;
            if (e.target.id === 'renderBtn') return;
            if (e.target.id === 'paletteUndoBtn') return;
            if (e.target.id === 'loadTexture') return;
            if (e.target.tagName === 'SELECT') return;
            if (e.target.tagName === 'BUTTON') return;
            
            paletteDragging = true;
            const rect = palette.getBoundingClientRect();
            paletteDragOffsetX = e.clientX - rect.left;
            paletteDragOffsetY = e.clientY - rect.top;
            palette.style.cursor = 'grabbing';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!paletteDragging) return;
            
            const palette = document.getElementById('colorPalette');
            const newX = e.clientX - paletteDragOffsetX;
            const newY = e.clientY - paletteDragOffsetY;
            
            // Constrain to viewport with some margin
            const margin = 20;
            const maxX = window.innerWidth - palette.offsetWidth - margin;
            const maxY = window.innerHeight - palette.offsetHeight - margin;
            
            palette.style.left = Math.max(margin, Math.min(maxX, newX)) + 'px';
            palette.style.top = Math.max(margin, Math.min(maxY, newY)) + 'px';
        });
        
        document.addEventListener('mouseup', (e) => {
            if (!paletteDragging) return;
            
            const palette = document.getElementById('colorPalette');
            paletteDragging = false;
            palette.style.cursor = 'move';
            
            // Check if palette should dock
            checkPaletteDocking(e.clientX - paletteDragOffsetX, e.clientY - paletteDragOffsetY);
        });

        // Brush Controls event listeners
        document.getElementById('controlsDetachBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            detachControls();
        });
        
        // Controls rotate button
        document.getElementById('controlsRotateBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const controls = document.getElementById('brushControls');
            controls.classList.toggle('vertical');
        });
        
        // Controls title click to show keyboard shortcuts
        document.getElementById('controlsTitle').addEventListener('click', (e) => {
            e.stopPropagation();
            const shortcuts = `üéÆ KEYBOARD SHORTCUTS\n\n` +
                `BRUSH TYPES:\n` +
                `R - Round brush\n` +
                `S - Square brush\n` +
                `T - Texture brush\n` +
                `O - Oil brush\n` +
                `D - Daub brush\n` +
                `E - Render brush\n` +
                `P - Pixel brush\n` +
                `F - Fill tool\n\n` +
                `PALETTE SHORTCUTS:\n` +
                `1-9 - Switch to palette 1-9\n\n` +
                `BRUSH SIZE:\n` +
                `[ - Decrease brush size\n` +
                `] - Increase brush size\n\n` +
                `UNDO/REDO:\n` +
                `Ctrl+Z - Undo\n` +
                `Ctrl+Y / Ctrl+Shift+Z - Redo`;
            alert(shortcuts);
        });
        
        // Controls dragging
        document.getElementById('brushControls').addEventListener('mousedown', (e) => {
            const controls = document.getElementById('brushControls');
            if (!controlsFloating) return;
            if (e.target.tagName === 'INPUT') return;
            if (e.target.tagName === 'BUTTON') return;
            if (e.target.tagName === 'LABEL') return;
            if (e.target.classList.contains('controls-title')) return;
            if (e.target.id === 'controlsDetachBtn') return;
            if (e.target.id === 'controlsRotateBtn') return;
            
            controlsDragging = true;
            const rect = controls.getBoundingClientRect();
            controlsDragOffsetX = e.clientX - rect.left;
            controlsDragOffsetY = e.clientY - rect.top;
            controls.style.cursor = 'grabbing';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!controlsDragging) return;
            
            const controls = document.getElementById('brushControls');
            const newX = e.clientX - controlsDragOffsetX;
            const newY = e.clientY - controlsDragOffsetY;
            
            // Constrain to viewport with some margin
            const margin = 20;
            const maxX = window.innerWidth - controls.offsetWidth - margin;
            const maxY = window.innerHeight - controls.offsetHeight - margin;
            
            controls.style.left = Math.max(margin, Math.min(maxX, newX)) + 'px';
            controls.style.top = Math.max(margin, Math.min(maxY, newY)) + 'px';
            controls.style.right = 'auto';
        });
        
        document.addEventListener('mouseup', (e) => {
            if (!controlsDragging) return;
            
            const controls = document.getElementById('brushControls');
            controlsDragging = false;
            controls.style.cursor = 'move';
            
            // Check if controls should dock
            checkControlsDocking(e.clientX - controlsDragOffsetX, e.clientY - controlsDragOffsetY);
        });

        // Intro PIN icon click handler
        document.getElementById('introPinIcon').addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Intro PIN icon clicked!');
            detachPalette();
            detachControls();
            updatePinIconText();
        });
    </script>

    <!-- Technical Documentation -->
    <div style="max-width: 900px; margin: 10px auto 40px; padding: 20px; background: rgba(42, 45, 58, 0.6); border-radius: 16px; backdrop-filter: blur(10px); color: #d8d8d8; line-height: 1.8;">
        <h2 style="font-size: 32px; margin-bottom: 16px; background: linear-gradient(135deg, #5a9ff5 0%, #a78bfa 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">Technical Documentation</h2>
        <p style="font-size: 14px; color: #b8b8c8; margin: 0 0 24px 0; text-align: left;">
            <strong>Note:</strong> This demonstration implements a simplified UI architecture suitable for <strong>technical exploration and portfolio presentation</strong>. A production-grade deployment would require additional layers including: collapsible toolbar systems with toggle states, modal parameter panels triggered via context menus, full-screen canvas mode with edge-anchored floating controls, and responsive viewport detection for adaptive UI scaling across different device classes.
        </p>
        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Project Overview</h3>
            <p style="font-size: 14px; color: #b8b8c8; margin: 0;">
                This application serves as an exploration of fundamental <strong>raster graphics manipulation</strong> techniques commonly implemented in professional <strong>digital illustration applications</strong>. 
                The demo showcases practical implementations of brush dynamics, compositing operations, frame-based animation systems, and <strong>real-time pixel manipulation</strong> using the HTML5 Canvas 2D API. 
                The architecture emphasises performant ImageData operations, <strong>efficient rendering pipelines</strong>, and modular brush system design patterns applicable to production-grade creative software.
            </p>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Core Brush System</h3>
            
            <h4 style="font-size: 16px; color: #87baca; margin-top: 20px; margin-bottom: 8px;">Brush Types & Rendering Algorithms</h4>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Round (r):</strong> Implements a radial gradient falloff stamp with configurable hardness using createRadialGradient(). Core algorithm for soft-edged brushes.</li>
                <li><strong>Square (s):</strong> Hard-edged rectangular stamp using direct fillRect() operations for pixel-perfect geometric shapes.</li>
                <li><strong>Texture (x):</strong> Professional stamp-based texture rendering system with PNG alpha channel preservation. Implements off-canvas compositing pipeline with rotation matrices (stroke-direction + stochastic variance), source-atop colour tinting, and automatic black-to-transparent preprocessing. Supports custom texture loading (256√ó256 or 512√ó512 recommended) with automatic ImageData manipulation for black pixel removal (RGB threshold < 10). Defaults to grunge-06.png. See dedicated Texture Brush section below for implementation details.</li>
                <li><strong>Oil (o):</strong> Advanced rectangular brush (2:1 aspect ratio) with adaptive colour mixing via ImageData sampling, directional lighting simulation, and edge contamination effects. Implements real-time colour blending with underlying canvas pixels (30% contamination factor).</li>
                <li><strong>Daub (d):</strong> Implements colour averaging within brush radius and applies directional smudging with opacity-weighted blending. Simulates paint mixing through multi-sample ImageData read operations and weighted averaging algorithms.</li>
                <li><strong>Render (e):</strong> Selective blur algorithm using luminance-based edge detection (contrast threshold: 80). Implements distance-weighted averaging within circular kernels while preserving high-contrast edges. Uses getLuminance() helper (ITU-R BT.601 coefficients: 0.299R + 0.587G + 0.114B).</li>
                <li><strong>Pixel (p):</strong> Snaps to down-sized, quantized grid coordinates with nearest-neighbor scaling. Directly manipulates frame ImageData at native resolution with immediate upscaling for display.</li>
                <li><strong>Fill (f):</strong> Stack-based flood fill implementation avoiding recursion limits. Uses visited set for cycle detection and 4-directional neighbor propagation.</li>
            </ul>

            <h4 style="font-size: 16px; color: #87baca; margin-top: 20px; margin-bottom: 8px;">Brush Dynamics & Parameters</h4>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Size:</strong> Base brush diameter (1-100px). Directly affects kernel size for sampling operations.</li>
                <li><strong>Opacity:</strong> Global alpha compositing with automatic scale switching. Standard mode: 0.1-1.0 range (0.1 increments). Fine-tune mode: 0-0.1 range (0.01 increments) activated when slider reaches minimum position, enabling precise low-opacity control for glazing and subtle layering. Slider thumb changes to pink gradient in fine-tune mode for visual feedback.</li>
                <li><strong>Hardness:</strong> Controls radial gradient falloff curve. Higher values create sharper edges by adjusting colour stop positions.</li>
                <li><strong>Spacing:</strong> Dual-mode interpolation system with toggle-able behavior (click label to switch modes). Lower values in either mode increase sample points at performance cost.
                    <ul style="margin-top: 8px;">
                        <li><strong>Smooth mode (default):</strong> Speed-based adaptive spacing where faster strokes automatically increase stamp density for gap-free rendering - lower values increase base density.</li>
                        <li><strong>Absolute mode:</strong> Fixed-distance spacing regardless of stroke velocity, providing precise control over stamp placement for texturing and stippling effects.</li>
                    </ul>
                </li>
                <li><strong>Flow:</strong> Per-stamp opacity multiplier enabling build-up effects through repeated application.</li>
                <li><strong>Scatter:</strong> Stochastic offset applied to stamp positions. Uses uniform random distribution within defined radius to displaced from its intended position.</li>
                <li><strong>Taper:</strong> Speed-based size modulation. Brush size decreases when moving slowly and increases when moving quickly, creating dynamic pressure simulation.</li>
                <li><strong>Jitter:</strong> Per-stamp randomisation of size and opacity (50% size variance, 30% opacity variance) for highly organic variation.</li>
            </ul>

            <h4 style="font-size: 16px; color: #87baca; margin-top: 20px; margin-bottom: 8px;">Brush Preset System (.jbrush Format)</h4>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>File Format:</strong> JSON-based .jbrush files for human-readable brush configurations. Structure includes metadata (name, version, author, created date), brush parameters object (all 11 dynamics parameters: size, opacity, hardness, spacing, flow, scatter, taper, jitter, rotationMode, spinAngle, colour), and application metadata (tags, app identifier, version).</li>
                <li><strong>Export Pipeline:</strong> JSON.stringify() serialisation with 2-space indentation for readability. Creates Blob with application/json MIME type and triggers download via dynamically created anchor element with Object URL.</li>
                <li><strong>Import Pipeline:</strong> FileReader API with readAsText() for asynchronous file loading. JSON.parse() deserialisation with try-catch error handling. Validates brush object existence before applying parameters to prevent corrupted file errors.</li>
                <li><strong>Parameter Mapping:</strong> Direct property assignment to primaryBrush object with fallback defaults for missing properties (defensive programming). Synchronizes all UI sliders and dropdowns via value assignment and dispatches change events to trigger preset application logic.</li>
                <li><strong>State Synchronisation:</strong> Automatically updates cursor visualisation (updateCursor()), active brush display (updateActiveBrushDisplay()), and applies brush-specific presets through an event dispatch mechanism.</li>
                <li><strong>Use Cases:</strong> Artist brush library creation, cross-session workflow persistence, community brush sharing, tutorial preset distribution, and backup/restoration of custom configurations.</li>
            </ul>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Texture Brush System</h3>
            <p style="font-size: 14px; color: #b8b8c8; margin-bottom: 16px;">
                The Texture brush implements a production-grade stamp-based rendering pipeline comparable to texture brush systems in professional illustration software. Unlike procedural brushes, texture brushes apply pre-rendered bitmap data with full alpha channel support, enabling complex organic patterns impossible to synthesize algorithmically in real-time.
            </p>
            
            <h4 style="font-size: 16px; color: #87baca; margin-top: 20px; margin-bottom: 8px;">Rendering Architecture</h4>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Off-Canvas Compositing:</strong> Each stamp is rendered to a temporary HTMLCanvasElement for multi-stage processing before final composition. This prevents taint issues and enables complex blend mode stacking without affecting the main canvas state.</li>
                <li><strong>Transform Pipeline:</strong> Applies 2D affine transformation matrix (translate ‚Üí rotate ‚Üí translate inverse) for stroke-direction-aligned rotation. Additional stochastic rotation variance (¬±0.25 radians) prevents repetitive patterns in continuous strokes.</li>
                <li><strong>Alpha Preservation:</strong> Uses source-atop compositing mode for colour tinting, which preserves the original texture's alpha channel. This is critical for maintaining brush shape fidelity as standard multiply mode would destroy transparency gradients.</li>
                <li><strong>Opacity Control:</strong> Secondary destination-in pass applies user-defined opacity via globalAlpha, creating a gradient mask that modulates the entire stamp uniformly. Maintains fine transparency control (0-0.1 fine mode with 0.01 steps).</li>
                <li><strong>Square Stamp Geometry:</strong> Unlike circular gradient brushes, texture brushes maintain square aspect ratio to prevent distortion of directional grain patterns (essential for materials like charcoal, wood grain, fabric weave).</li>
            </ul>

            <h4 style="font-size: 16px; color: #87baca; margin-top: 20px; margin-bottom: 8px;">Texture Processing Pipeline</h4>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Black-to-Transparent Conversion:</strong> Preprocessing step converts dark pixels (RGB < 10 threshold) to full transparency (alpha = 0) via ImageData manipulation. This enables "black and white texture" workflow where artists draw texture shapes in black on white backgrounds, with black defining the brush silhouette.</li>
                <li><strong>Async Loading:</strong> Image.onload callback chain ensures texture processing completes before brush availability. Uses data URL intermediary (canvas.toDataURL()) for processed image storage, creating clean Image objects from manipulated pixel data.</li>
                <li><strong>CORS Handling:</strong> Sets crossOrigin = 'anonymous' attribute with try-catch fallback for getImageData() operations. Gracefully degrades to unprocessed texture if security restrictions prevent pixel access (file:// protocol).</li>
                <li><strong>Format Support:</strong> Accepts PNG and JPEG via FileReader API with client-side validation. PNG recommended for alpha channel support; JPEG usable for opaque textures.</li>
                <li><strong>Size Validation:</strong> Warns users when loading textures > 1024√ó1024 due to memory overhead and potential frame rate degradation during real-time drawing. Optimal range: 256√ó256 to 512√ó512 for balance between detail and performance.</li>
            </ul>

            <h4 style="font-size: 16px; color: #87baca; margin-top: 20px; margin-bottom: 8px;">Default Texture & Custom Loading</h4>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Default Texture:</strong> grunge-06.png loaded on initialization via loadDefaultTexture() with automatic black-to-transparent preprocessing. Provides immediate texture brush functionality without user action.</li>
                <li><strong>Load Texture Button:</strong> Context-sensitive UI element (visible only when Texture brush active) triggers file picker with pre-selection tips dialog. Confirms texture format requirements (black/white, size recommendations) before opening native file chooser.</li>
                <li><strong>Texture State Management:</strong> Global brushTexture reference updated on successful load with textureLoaded flag preventing race conditions. Fallback to solid square stamp if texture unavailable (async loading incomplete or error state).</li>
                <li><strong>Auto-Preset Application:</strong> Switching to Texture brush automatically sets Size=100, Opacity=0.06 (fine mode), Flow=1.0 for optimal texture application parameters. Larger size necessary for texture detail visibility; low opacity enables gradual buildup.</li>
            </ul>

            <h4 style="font-size: 16px; color: #87baca; margin-top: 20px; margin-bottom: 8px;">Performance Considerations</h4>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Canvas Reuse:</strong> Temporary canvas created per stamp rather than cached to avoid state pollution. V8 optimization recognises allocation pattern and JIT-compiles efficient object pool.</li>
                <li><strong>Transform Overhead:</strong> 2D rotation matrix calculation (Math.atan2, translate, rotate) adds ~0.1ms per stamp on modern hardware - negligible for typical stroke densities (spacing ‚â• 1.0).</li>
                <li><strong>ImageData Manipulation:</strong> Black-to-transparent conversion is O(n) where n = width √ó height √ó 4 (RGBA). For 512√ó512 texture: ~1M operations, completes in <5ms on desktop CPUs. Performed once per texture load, not per stamp.</li>
                <li><strong>Memory Profile:</strong> Each texture stored as Image object (~width √ó height √ó 4 bytes). 512√ó512 RGBA ‚âà 1MB. Temporary canvases garbage collected after composition, preventing memory leaks during extended drawing sessions.</li>
            </ul>

            <h4 style="font-size: 16px; color: #87baca; margin-top: 20px; margin-bottom: 8px;">Comparison to Industry Implementations</h4>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Procreate Valkyrie:</strong> Uses Metal compute shaders for GPU-accelerated texture stamping with real-time grain rotation and dual-texture layering. This Canvas 2D implementation shares core concepts (stamp compositing, rotation, alpha preservation) using CPU rasterization - suitable for web context where GPU access is limited.</li>
                <li><strong>Photoshop ABR:</strong> Supports multiple texture layers per brush tip with blend mode stacking and scatter matrices. This implementation only focuses on single-texture workflow with manual layering via opacity buildup - appropriate for educational/demonstration context.</li>
                <li><strong>Krita Texture Brushes:</strong> Implements pattern offset and scale randomization for non-repetitive application. This demo includes rotation randomization; pattern offset could be added via random texture sampling coordinates (partial implementation ready in commented code).</li>
            </ul>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Pixel Art Mode Implementation</h3>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Resolution System:</strong> Canvas operates at 100√ó56 native resolution (16:9 aspect ratio) with 8√ó upscaling to 800√ó450 display resolution.</li>
                <li><strong>Scaling Algorithm:</strong> Nearest-neighbour interpolation (imageSmoothingEnabled = false) preserves hard pixel edges during upscaling operations.</li>
                <li><strong>Grid Overlay:</strong> Conditionally rendered when pixelScale ‚â• 4 using semi-transparent stroke operations for visual grid alignment.</li>
                <li><strong>Coordinate Transformation:</strong> Mouse coordinates mapped to pixel grid via Math.floor(x / pixelScale) for precise pixel targeting.</li>
                <li><strong>Frame Management:</strong> All frames stored at native pixel art resolution. Upscaling applied per-frame during rendering pipeline.</li>
                <li><strong>Export Pipeline:</strong> Exports at native 100√ó56 resolution preserving original pixel art without interpolation artifacts.</li>
                <li><strong>Mode Isolation:</strong> Mutually exclusive with Timelapse Challenge to prevent conflicting render pipelines.</li>
            </ul>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Animation Framework</h3>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Frame Storage:</strong> Array of ImageData objects enabling efficient frame manipulation without canvas redraws.</li>
                <li><strong>Onion Skinning:</strong> Composites previous frame at 30% opacity using temporary canvas and drawImage() with globalAlpha modulation.</li>
                <li><strong>Playback System:</strong> setInterval-based animation loop at 10 FPS (100ms intervals) with frame cycling via modulo arithmetic.</li>
                <li><strong>GIF Export:</strong> Integration with gifshot library for client-side GIF encoding. Converts ImageData to data URLs for processing.</li>
                <li><strong>Frame Interpolation:</strong> Smooth slider-based navigation with real-time frame switching and display updates.</li>
            </ul>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Timelapse Challenge System</h3>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Snapshot Capture:</strong> Automatic frame capture after each stroke completion, storing as data URLs for memory efficiency.</li>
                <li><strong>Stroke Limitation:</strong> 30-stroke constraint enforced through state management and drawing block flags.</li>
                <li><strong>GIF Generation:</strong> Sequential snapshot compilation into timelapse animation with 150ms frame duration (3 frameDuration units).</li>
                <li><strong>State Management:</strong> Modal drawing restriction preventing further input after stroke limit reached.</li>
                <li><strong>Proof of Work:</strong> The timelapse recording serves as cryptographic-style proof of human creative process, providing verifiable evidence of manual creation to distinguish authentic human-generated artwork from AI-synthesized images. Each incremental snapshot forms an immutable chain of artistic decision-making.</li>
            </ul>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Colour Palette System</h3>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Palette Architecture:</strong> Object array structure containing name metadata and 20-colour hex arrays for easy extensibility.</li>
                <li><strong>Dynamic Switching:</strong> Modulo-based cycling through a number of curated palettes with automatic DOM regeneration and state preservation.</li>
                <li><strong>Eyedropper Tool:</strong> Direct pixel sampling via getImageData() with hex conversion for colour picking from canvas content.</li>
                <li><strong>Palettes Included:</strong> FARMLAND-20 (Eclipse89), ARTBOUND (Doph), DUNGEON-20 (Meaghan), MIXEDBAG[20] (SoundsDotZip), SOGGY 20 (green guy), ELEMENTAL (Space Sandwich), 20P DX (GrafxKid), MOJAVE20 (magodellepercussioni), GRAY WEATHER (Cactus Celery).</li>
            </ul>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Rendering Optimisations</h3>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Stroke Interpolation:</strong> Bresenham-inspired spacing calculations prevent gaps in fast strokes while maintaining performance.</li>
                <li><strong>Click-to-Paint:</strong> Immediate drawPixel() invocation on mousedown event ensures single-click responsiveness.</li>
                <li><strong>Cursor Generation:</strong> Dynamic canvas-based cursor creation with type-specific shapes.</li>
                <li><strong>Render Button:</strong> Scanline-based progressive rendering with requestAnimationFrame for non-blocking full-canvas blur operations with visual feedback.</li>
                <li><strong>Bounds Checking:</strong> Consistent boundary validation prevents ImageData access violations during edge cases.</li>
                <li><strong>Context State Management:</strong> ctx.save()/restore() pairs ensure clean state isolation for compositing operations.</li>
            </ul>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #a78bfa; margin-bottom: 12px; border-bottom: 2px solid rgba(167, 139, 250, 0.3); padding-bottom: 8px;">Quality of Life (QoL) Features</h3>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Undo/Redo System:</strong> Full stroke history with Ctrl+Z (undo) and Ctrl+Y/Ctrl+Shift+Z (redo) keyboard shortcuts. Maintains last 20 states with efficient ImageData cloning for memory management. Automatically saves state after strokes, fill operations, clear canvas, and render effects.</li>
                <li><strong>Eyedropper Auto-Revert:</strong> Automatically restores the previously selected brush type after color picking, eliminating manual reselection and maintaining workflow continuity.</li>
                <li><strong>Keyboard Shortcuts:</strong> Single-letter shortcuts displayed in dropdown for all 8 brush types (r=round, s=square, t=texture, o=oil, d=daub, e=render, p=pixel, f=fill) enabling rapid brush switching without mouse interaction. Number keys 1-9 instantly switch between colour palettes. Bracket keys [ and ] decrease/increase brush size by 2px increments (clamped to 1-50px range) with real-time cursor feedback.</li>
                <li><strong>Click-to-Paint:</strong> Single clicks immediately register strokes rather than requiring drag motion, essential for precise dot placement and stippling techniques.</li>
                <li><strong>Dynamic Cursor Visualisation:</strong> Real-time cursor updates reflect current brush type and size with custom canvas-rendered shapes (circular, rectangular, square) providing accurate visual feedback before stroke application.</li>
                <li><strong>Onion Skinning:</strong> Toggle-based previous frame overlay at 30% opacity enables precise frame-to-frame animation refinement without external reference layers.</li>
                <li><strong>Global Mouse Release Detection:</strong> Listens for mouseup events on document rather than canvas only, preventing "stuck drawing" when cursor leaves canvas bounds during stroke - critical for edge-case handling.</li>
                <li><strong>Boundary-Safe Drawing:</strong> Automatic coordinate clamping prevents strokes when cursor exits canvas area, avoiding unintended marks and state corruption.</li>
                <li><strong>Auto-Preset Application:</strong> Brush-specific defaults automatically applied on selection (Pixel: all parameters optimized for pixel art; Oil: scatter=25 for organic texture) reducing manual slider adjustment.</li>
                <li><strong>Mode Conflict Prevention:</strong> Mutual exclusion alerts between Pixel Art mode and Timelapse Challenge prevent incompatible state combinations with clear user messaging.</li>
                <li><strong>Touch Device Support:</strong> Full touch event handling with preventDefault() for gesture conflicts enables iPad/tablet usage with identical functionality to desktop mouse control.</li>
                <li><strong>Frame Slider Navigation:</strong> Scrub through animation frames via slider with real-time preview and onion skin persistence, avoiding repetitive button clicks for frame review.</li>
                <li><strong>Progressive Render Feedback:</strong> Scanline animation during Render button operation provides visual progress indication preventing perceived application freeze during heavy processing.</li>
                <li><strong>One-Click Export:</strong> Direct PNG/GIF download without intermediate dialogs or confirmations streamlines asset extraction workflow.</li>
                <li><strong>Palette Hot-Swapping:</strong> Single-click palette name cycling with automatic colour grid regeneration and state preservation enables rapid colour scheme exploration.</li>
                <li><strong>Brush Presets (.jbrush):</strong> Export and import custom brush configurations as JSON-based .jbrush files containing all 11 parameters (size, opacity, hardness, spacing, flow, scatter, taper, jitter, rotationMode, spinAngle, colour). Enables brush library creation, sharing between artists, and persistent workflow customisation across sessions.</li>
                <li><strong>Stroke Stabilisation:</strong> Optional line stabilisation system with adjustable strength (0-100%) that reduces hand tremor and jitter using weighted point averaging. Particularly beneficial for mouse users or drawing on trackpads without graphics tablets. Uses rolling buffer of last 5 points with exponential weighting favouring recent positions. Toggle on/off via button without affecting existing workflow.</li>
                <li><strong>Detachable Colour Palette:</strong> Floating palette system with drag-and-drop repositioning. Click pin icon (üìå) to detach palette into floating mode, enabling placement anywhere over canvas or surrounding UI. Drag palette by any empty area while floating. Auto-docks when dragged near original position (50px threshold). Maintains state and selections during detach/dock operations.</li>
                <li><strong>Opacity Fine-Tuning Mode:</strong> Automatic scale switching for precise low-opacity control. When opacity slider reaches 0.1 (leftmost position), scale automatically changes to 0-0.1 range with 0.01 increments for detailed transparency work. Moving slider back to 0.1 (now rightmost position) reverts to standard 0.1-1.0 scale. Enables precise control for subtle glazing and layering techniques without separate fine adjustment controls.</li>
            </ul>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Technical Architecture Highlights</h3>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Event System:</strong> Touch and mouse event normalisation for cross-device compatibility with preventDefault() for gesture handling.</li>
                <li><strong>State Management:</strong> Centralised brush state objects with reactive UI synchronisation via event listeners.</li>
                <li><strong>Mode Switching:</strong> Automatic brush preset application (pixel art: hardness=1, spacing=0.1; oil: scatter=25).</li>
                <li><strong>Memory Management:</strong> ImageData caching for frames with efficient data URL conversion for export operations.</li>
                <li><strong>Colour Space Handling:</strong> RGB/hex conversion utilities with proper colour parsing for cross-format compatibility.</li>
            </ul>
        </section>

        <section style="margin-bottom: 36px;">
            <h3 style="font-size: 20px; color: #5a9ff5; margin-bottom: 12px; border-bottom: 2px solid rgba(90, 159, 245, 0.3); padding-bottom: 8px;">Debugging</h3>
            <ul style="font-size: 14px; color: #b8b8c8; line-height: 1.9;">
                <li><strong>Extensive Debugging:</strong> Something I take great satisfaction in mastering, as comprehensive debugging methodologies are critical to the reliability, performance, and reputation of any project.</li>
                <li><strong>Onion Skinning:</strong> Debugging still in progress for frame-accurate animation visualization.</li>
            </ul>
        </section>

        <p style="font-size: 13px; color: #8a8d98; margin-top: 36px; padding-top: 24px; border-top: 1px solid rgba(90, 159, 245, 0.2); text-align: center;">
            <strong>Technologies:</strong> HTML5 Canvas 2D API, Vanilla JavaScript ES6+, gifshot (v0.4.5), CSS3 Gradients & Backdrop Filters<br>
            <strong>License:</strong> MIT | <strong>Author:</strong> Jaydz Dev | <strong>Version:</strong> 0.1
        </p>
    </div>

</body>
</html>