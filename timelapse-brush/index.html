<!DOCTYPE html>
<html lang="en">
<!--
    Timelapse Brush Simulator
    Copyright (c) 2025 Jaydz Dev
    Licensed under the MIT License
    
    This software uses gifshot (https://github.com/yahoo/gifshot)
    Copyright (c) Yahoo Inc., licensed under the MIT License
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timelapse Brush Simulator (v0.1)</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 1px solid #444;
            background-color: white;
            cursor: crosshair;
            touch-action: none; /* For touch devices */
        }
        .controls {
            margin: 10px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .controls input, .controls button, .controls select {
            padding: 5px;
            font-size: 14px;
            background-color: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
        }
        .animation-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .frame-display {
            width: 50px;
            text-align: center;
        }
        button {
            background-color: #0a84ff;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0066cc;
        }
        button:disabled {
            background-color: #444;
            color: #888;
        }
        .color-palette {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 5px;
            max-width: 370px;
            margin: 5px 0;
        }
        .color-swatch {
            width: 32px;
            height: 32px;
            border: 2px solid #444;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .color-swatch:hover {
            transform: scale(1.1);
            border-color: #0a84ff;
        }
        .color-swatch.selected {
            border: 3px solid #0a84ff;
            box-shadow: 0 0 5px #0a84ff;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
</head>
<body>
    <h1>Timelapse Brush Simulator (v0.1)</h1>
    <h3>By Jaydz Dev</h3>
    <p>Draw with customizable brushes, create dual effects, and animate frames with onion skinning.</p>
    
    <!-- Timelapse Challenge Controls -->
    <div style="margin: 10px 0;">
        <button id="startTimelapse" style="font-size: 16px; padding: 10px 20px;">ðŸŽ¨ Start Timelapse Challenge</button>
    </div>
    
    <!-- Timelapse Challenge Display -->
    <div id="timelapseChallenge" style="display: none; background: #2a2a2a; border: 2px solid #ffeb3b; padding: 10px; border-radius: 5px; margin: 10px 0; font-weight: bold; font-size: 18px;">
        ðŸŽ¨ Strokes Remaining: <span id="strokeCount">30</span> | <button id="exportTimelapse" disabled>Export Timelapse</button>
    </div>

    <!-- Main Canvas -->
    <canvas id="canvas" width="800" height="600"></canvas>

    <!-- Brush Controls -->
    <div class="controls">
        <label>Size: <input type="range" id="brushSize" min="1" max="50" value="30"></label>
        <label>Opacity: <input type="range" id="brushOpacity" min="0.1" max="1" step="0.1" value="1"></label>
        <label>Hardness: <input type="range" id="brushHardness" min="0" max="1" step="0.1" value="0.5"></label>
    </div>
    
    <!-- Color Palette -->
    <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; margin: 10px 0;">
        <label style="font-weight: bold;">Color Palette:</label>
        <div class="color-palette" id="colorPalette"></div>
        <button id="eyedropper">ðŸŽ¨ Eyedropper</button>
    </div>
    
    <div class="controls">
        <label>Brush Type: 
            <select id="brushType">
                <option value="round">Round</option>
                <option value="square" selected>Square</option>
                <option value="textured">Textured</option>
                <option value="oil">Oil</option>
                <option value="blend">Blend</option>
                <option value="fill">Fill</option>
            </select>
        </label>
        <button id="enableDual">Enable Dual Brush</button>
        <button id="clearCanvas">Clear</button>
        <button id="export">Export PNG</button>
    </div>

    <!-- Animation Controls -->
    <div class="animation-controls">
        <button id="addFrame">Add Frame</button>
        <button id="playAnimation">Play</button>
        <button id="toggleOnion">Toggle Onion Skin</button>
        <button id="exportGif">Export GIF</button>
        <span class="frame-display">Frame: <span id="currentFrame">1</span> / <span id="totalFrames">1</span></span>
        <input type="range" id="frameSlider" min="1" max="1" value="1" style="width: 200px;">
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true, willReadFrequently: false });
        ctx.imageSmoothingEnabled = true; // Smooth rendering
        ctx.imageSmoothingQuality = 'low'; // Performance over quality

        // Helper function to create a white frame
        function createWhiteFrame() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            // Fill with white (RGB: 255, 255, 255, Alpha: 255)
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255;     // Red
                data[i + 1] = 255; // Green
                data[i + 2] = 255; // Blue
                data[i + 3] = 255; // Alpha
            }
            return imageData;
        }

        // Animation state
        let frames = [createWhiteFrame()]; // Start with white frame
        let currentFrameIndex = 0;
        let isPlaying = false;
        let onionSkin = true;
        let animationInterval;

        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let dualBrushEnabled = false;
        let primaryBrush = { type: 'round', size: 10, opacity: 1, hardness: 0.5, color: '#8d9855' };
        let secondaryBrush = { type: 'textured', size: 8, opacity: 1, hardness: 0.3, color: '#ecf3b0' };

        // Custom 20-color palette (sorted by hue/brightness)
        const colorPalette = [
            '#0c0f00', // Black
            '#1c2025', // Dark Blue-Gray
            '#2d3c56', // Dark Blue
            '#536871', // Blue-Gray
            '#548ca4', // Blue
            '#879797', // Gray
            '#8bb3c1', // Light Blue
            '#b8ddd2', // Cyan
            '#ecf3b0', // Light Yellow-Green
            '#c8ad56', // Yellow
            '#8d9855', // Olive Green
            '#4b5431', // Dark Green
            '#7a7b6b', // Gray-Green
            '#40291c', // Dark Brown
            '#672d20', // Brown
            '#725336', // Medium Brown
            '#953a2f', // Red-Brown
            '#9f865b', // Tan
            '#ac6b2f', // Orange-Brown
            '#50486a'  // Purple-Gray
        ];

        // Timelapse challenge state
        let timelapseMode = false;
        let strokesRemaining = 30;
        let timelapseSnapshots = [];
        let drawingBlocked = false;

        // Eyedropper state
        let eyedropperMode = false;

        // Update display
        function updateFrameDisplay() {
            document.getElementById('currentFrame').textContent = currentFrameIndex + 1;
            document.getElementById('totalFrames').textContent = frames.length;
            document.getElementById('frameSlider').max = frames.length;
            document.getElementById('frameSlider').value = currentFrameIndex + 1;
        }

        // Switch frames
        function switchFrame(index) {
            // Clear canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw onion skin first (if enabled) using a temporary canvas
            if (onionSkin && index > 0) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(frames[index - 1], 0, 0);
                ctx.globalAlpha = 0.3;
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.globalAlpha = 1;
            }
            
            // Draw current frame on top using drawImage to preserve onion skin
            const currentCanvas = document.createElement('canvas');
            currentCanvas.width = canvas.width;
            currentCanvas.height = canvas.height;
            const currentCtx = currentCanvas.getContext('2d');
            currentCtx.putImageData(frames[index], 0, 0);
            ctx.drawImage(currentCanvas, 0, 0);
            
            currentFrameIndex = index;
            updateFrameDisplay();
        }

        // Drawing functions
        function getBrushGradient(x, y, size, hardness, color) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gradient.addColorStop(0, color);
            gradient.addColorStop(hardness, color);
            gradient.addColorStop(1, color + '00'); // Fade to transparent
            return gradient;
        }

        // Helper function to adjust color brightness
        function adjustBrightness(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
            const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
            const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // Flood fill function
        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            
            // Convert fill color to RGB
            const hex = fillColor.replace('#', '');
            const fillR = parseInt(hex.substr(0, 2), 16);
            const fillG = parseInt(hex.substr(2, 2), 16);
            const fillB = parseInt(hex.substr(4, 2), 16);
            
            // Get start pixel color
            const startPos = (startY * canvas.width + startX) * 4;
            const startR = pixels[startPos];
            const startG = pixels[startPos + 1];
            const startB = pixels[startPos + 2];
            
            // Don't fill if same color
            if (startR === fillR && startG === fillG && startB === fillB) {
                return;
            }
            
            // Stack-based flood fill to avoid recursion limits
            const stack = [[startX, startY]];
            const visited = new Set();
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key)) continue;
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                
                const pos = (y * canvas.width + x) * 4;
                const r = pixels[pos];
                const g = pixels[pos + 1];
                const b = pixels[pos + 2];
                
                // Check if pixel matches start color
                if (r === startR && g === startG && b === startB) {
                    visited.add(key);
                    
                    // Fill pixel
                    pixels[pos] = fillR;
                    pixels[pos + 1] = fillG;
                    pixels[pos + 2] = fillB;
                    pixels[pos + 3] = 255; // Full opacity
                    
                    // Add neighbors to stack
                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function drawPixel(x, y, size, opacity, hardness, color, type, directionX = 0, directionY = 0) {
            ctx.save();
            ctx.globalAlpha = opacity;
            const halfSize = size / 2;
            if (type === 'round') {
                ctx.beginPath();
                ctx.arc(x, y, halfSize, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
            } else if (type === 'square') {
                // Simple square brush - fast and efficient
                ctx.fillStyle = color;
                ctx.fillRect(x - halfSize, y - halfSize, size, size);
            } else if (type === 'textured') {
                // Simple texture simulation: noise pattern
                ctx.fillStyle = color;
                for (let i = 0; i < 10; i++) {
                    const tx = x + (Math.random() - 0.5) * size;
                    const ty = y + (Math.random() - 0.5) * size;
                    ctx.fillRect(tx, ty, size / 5, size / 5);
                }
            } else if (type === 'oil') {
                // Oil brush: Square brush with blends colors and directional lighting effects
                ctx.globalCompositeOperation = 'source-over';
                
                // Sample the underlying canvas color for blending
                const imageData = ctx.getImageData(x - halfSize, y - halfSize, size, size);
                
                // Main brush stroke with base color (square)
                ctx.globalAlpha = opacity * 0.6;
                ctx.fillStyle = color;
                ctx.fillRect(x - halfSize, y - halfSize, size, size);
                
                // Add directional edge highlights and shadows
                const angle = Math.atan2(directionY, directionX);
                
                // Lighter edge on the leading side (square)
                ctx.globalAlpha = opacity * 0.3;
                const lightOffset = halfSize * 0.4;
                const lightX = x + Math.cos(angle) * lightOffset;
                const lightY = y + Math.sin(angle) * lightOffset;
                const lightSize = size * 0.6;
                ctx.fillStyle = adjustBrightness(color, 40);
                ctx.fillRect(lightX - lightSize / 2, lightY - lightSize / 2, lightSize, lightSize);
                
                // Darker edge on the trailing side (square)
                ctx.globalAlpha = opacity * 0.25;
                const darkX = x - Math.cos(angle) * lightOffset;
                const darkY = y - Math.sin(angle) * lightOffset;
                const darkSize = size * 0.5;
                ctx.fillStyle = adjustBrightness(color, -40);
                ctx.fillRect(darkX - darkSize / 2, darkY - darkSize / 2, darkSize, darkSize);
                
                // Add some texture/grain
                ctx.globalAlpha = opacity * 0.15;
                for (let i = 0; i < 8; i++) {
                    const tx = x + (Math.random() - 0.5) * size * 0.8;
                    const ty = y + (Math.random() - 0.5) * size * 0.8;
                    const tsize = size / 8;
                    ctx.fillStyle = Math.random() > 0.5 ? adjustBrightness(color, 20) : adjustBrightness(color, -20);
                    ctx.fillRect(tx, ty, tsize, tsize);
                }
            } else if (type === 'blend') {
                // Blend brush: Mixes and smudges paint, creating new colors
                const blendRadius = Math.floor(halfSize);
                const sourceX = Math.max(0, Math.floor(x - blendRadius));
                const sourceY = Math.max(0, Math.floor(y - blendRadius));
                const blendSize = Math.min(size, canvas.width - sourceX, canvas.height - sourceY);
                
                if (blendSize > 0) {
                    // Sample the current area and areas around it for color mixing
                    const imageData = ctx.getImageData(sourceX, sourceY, blendSize, blendSize);
                    const data = imageData.data;
                    
                    // Calculate average color in the brush area for mixing
                    let totalR = 0, totalG = 0, totalB = 0, totalA = 0;
                    let pixelCount = 0;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const alpha = data[i + 3];
                        if (alpha > 0) {
                            totalR += data[i] * alpha;
                            totalG += data[i + 1] * alpha;
                            totalB += data[i + 2] * alpha;
                            totalA += alpha;
                            pixelCount++;
                        }
                    }
                    
                    if (totalA > 0) {
                        // Calculate mixed color
                        const avgR = Math.round(totalR / totalA);
                        const avgG = Math.round(totalG / totalA);
                        const avgB = Math.round(totalB / totalA);
                        const mixedColor = `rgb(${avgR}, ${avgG}, ${avgB})`;
                        
                        // Calculate smudge direction
                        const smudgeDistance = size * 0.4 * opacity;
                        const angle = Math.atan2(directionY, directionX);
                        const offsetX = Math.cos(angle) * smudgeDistance;
                        const offsetY = Math.sin(angle) * smudgeDistance;
                        
                        // Apply the mixed color with a gradient effect
                        ctx.globalCompositeOperation = 'source-over';
                        
                        // Draw several overlapping layers to create smooth color mixing
                        for (let layer = 0; layer < 5; layer++) {
                            const layerProgress = layer / 4;
                            const layerX = x + offsetX * layerProgress;
                            const layerY = y + offsetY * layerProgress;
                            
                            ctx.globalAlpha = opacity * (0.25 - layer * 0.03);
                            ctx.fillStyle = mixedColor;
                            ctx.beginPath();
                            ctx.arc(layerX, layerY, halfSize * (0.9 - layer * 0.1), 0, 2 * Math.PI);
                            ctx.fill();
                        }
                        
                        // Also move some of the original pixels for texture
                        ctx.globalAlpha = opacity * 0.4;
                        ctx.putImageData(imageData, sourceX + offsetX * 0.7, sourceY + offsetY * 0.7);
                    }
                }
            }
            ctx.restore();
        }

        function drawStroke(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;

            if (!isDrawing) {
                lastX = x;
                lastY = y;
                return;
            }

            // Skip if lastX or lastY is null (new stroke)
            if (lastX === null || lastY === null) {
                lastX = x;
                lastY = y;
                return;
            }

            // Get current brush settings
            primaryBrush.size = parseInt(document.getElementById('brushSize').value);
            primaryBrush.opacity = parseFloat(document.getElementById('brushOpacity').value);
            primaryBrush.hardness = parseFloat(document.getElementById('brushHardness').value);
            // Color is now managed by palette clicks, not input element
            primaryBrush.type = document.getElementById('brushType').value;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Calculate brush direction for oil brush
            const distance = Math.sqrt((x - lastX) ** 2 + (y - lastY) ** 2);
            const directionX = distance > 0 ? (x - lastX) / distance : 0;
            const directionY = distance > 0 ? (y - lastY) / distance : 0;

            // Smooth line drawing with optimized interpolation
            const steps = Math.max(1, Math.ceil(distance / (primaryBrush.size * 0.5))); // Balanced speed/smoothness
            for (let i = 0; i <= steps; i++) {
                const interpX = lastX + (x - lastX) * (i / steps);
                const interpY = lastY + (y - lastY) * (i / steps);
                drawPixel(interpX, interpY, primaryBrush.size, primaryBrush.opacity, primaryBrush.hardness, primaryBrush.color, primaryBrush.type, directionX, directionY);

                // Dual brush: Overlay secondary brush at every step for better color mix
                if (dualBrushEnabled) {
                    drawPixel(interpX, interpY, secondaryBrush.size, secondaryBrush.opacity, secondaryBrush.hardness, secondaryBrush.color, secondaryBrush.type, directionX, directionY);
                }
            }

            lastX = x;
            lastY = y;
        }

        // Event listeners for drawing
        function startDrawing(e) {
            e.preventDefault();
            
            // Eyedropper mode: pick color
            if (eyedropperMode) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX || e.touches[0].clientX) - rect.left);
                const y = Math.floor((e.clientY || e.touches[0].clientY) - rect.top);
                
                // Get pixel color at click position
                const imageData = ctx.getImageData(x, y, 1, 1);
                const pixel = imageData.data;
                const r = pixel[0];
                const g = pixel[1];
                const b = pixel[2];
                
                // Convert to hex
                const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                
                // Set brush color and update palette selection
                primaryBrush.color = hex.toUpperCase();
                
                // Try to select matching palette color if it exists
                const swatches = document.querySelectorAll('.color-swatch');
                swatches.forEach(swatch => {
                    swatch.classList.remove('selected');
                    if (swatch.style.backgroundColor.toUpperCase() === hex.toUpperCase() ||
                        rgbToHex(swatch.style.backgroundColor).toUpperCase() === hex.toUpperCase()) {
                        swatch.classList.add('selected');
                    }
                });
                
                // Exit eyedropper mode
                eyedropperMode = false;
                canvas.style.cursor = 'crosshair';
                document.getElementById('eyedropper').textContent = 'ðŸŽ¨ Eyedropper';
                return;
            }
            
            // Block drawing if timelapse challenge is complete
            if (drawingBlocked) {
                return;
            }
            
            // Check if fill tool is selected
            const brushType = document.getElementById('brushType').value;
            if (brushType === 'fill') {
                // Fill mode: perform flood fill on click
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.putImageData(frames[currentFrameIndex], 0, 0);
                
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX || e.touches[0].clientX) - rect.left);
                const y = Math.floor((e.clientY || e.touches[0].clientY) - rect.top);
                
                const fillColor = document.getElementById('brushColor').value;
                floodFill(x, y, fillColor);
                
                // Save the filled state
                frames[currentFrameIndex] = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Redraw with onion skin if enabled
                if (onionSkin && currentFrameIndex > 0) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(frames[currentFrameIndex - 1], 0, 0);
                    ctx.globalAlpha = 0.3;
                    ctx.drawImage(tempCanvas, 0, 0);
                    ctx.globalAlpha = 1;
                    const currentCanvas = document.createElement('canvas');
                    currentCanvas.width = canvas.width;
                    currentCanvas.height = canvas.height;
                    const currentCtx = currentCanvas.getContext('2d');
                    currentCtx.putImageData(frames[currentFrameIndex], 0, 0);
                    ctx.drawImage(currentCanvas, 0, 0);
                }
                
                // Capture snapshot for timelapse if active
                if (timelapseMode && strokesRemaining > 0) {
                    const snapshotCanvas = document.createElement('canvas');
                    snapshotCanvas.width = canvas.width;
                    snapshotCanvas.height = canvas.height;
                    const snapshotCtx = snapshotCanvas.getContext('2d');
                    snapshotCtx.putImageData(frames[currentFrameIndex], 0, 0);
                    timelapseSnapshots.push(snapshotCanvas.toDataURL('image/png'));
                    strokesRemaining--;
                    document.getElementById('strokeCount').textContent = strokesRemaining;
                    if (strokesRemaining === 0) {
                        drawingBlocked = true;
                        document.getElementById('exportTimelapse').disabled = false;
                        document.getElementById('strokeCount').textContent = '0 - Challenge Complete!';
                        alert('ðŸŽ‰ Challenge Complete! You can now export your timelapse.');
                    }
                }
                
                return; // Don't start normal drawing
            }
            
            isDrawing = true;
            // Clear canvas and redraw current frame without onion skin
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(frames[currentFrameIndex], 0, 0);
            // Set lastX and lastY to the current position to start a fresh stroke
            const rect = canvas.getBoundingClientRect();
            lastX = (e.clientX || e.touches[0].clientX) - rect.left;
            lastY = (e.clientY || e.touches[0].clientY) - rect.top;
        }

        function draw(e) {
            e.preventDefault();
            if (isDrawing) {
                drawStroke(e);
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            
            // Save the current state
            frames[currentFrameIndex] = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Timelapse mode: capture snapshot after each stroke
            if (timelapseMode && strokesRemaining > 0) {
                // Create snapshot canvas
                const snapshotCanvas = document.createElement('canvas');
                snapshotCanvas.width = canvas.width;
                snapshotCanvas.height = canvas.height;
                const snapshotCtx = snapshotCanvas.getContext('2d');
                snapshotCtx.putImageData(frames[currentFrameIndex], 0, 0);
                
                // Store as data URL (more memory efficient than keeping canvas objects)
                timelapseSnapshots.push(snapshotCanvas.toDataURL('image/png'));
                
                // Decrement strokes
                strokesRemaining--;
                document.getElementById('strokeCount').textContent = strokesRemaining;
                
                // Check if challenge is complete
                if (strokesRemaining === 0) {
                    drawingBlocked = true;
                    document.getElementById('exportTimelapse').disabled = false;
                    document.getElementById('strokeCount').textContent = '0 - Challenge Complete!';
                    alert('ðŸŽ‰ Challenge Complete! You can now export your timelapse.');
                }
            }
            
            // Redraw with onion skin if enabled using a temporary canvas
            if (onionSkin && currentFrameIndex > 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw previous frame with transparency
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(frames[currentFrameIndex - 1], 0, 0);
                ctx.globalAlpha = 0.3;
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.globalAlpha = 1;
                
                // Draw current frame on top using drawImage to preserve onion skin
                const currentCanvas = document.createElement('canvas');
                currentCanvas.width = canvas.width;
                currentCanvas.height = canvas.height;
                const currentCtx = currentCanvas.getContext('2d');
                currentCtx.putImageData(frames[currentFrameIndex], 0, 0);
                ctx.drawImage(currentCanvas, 0, 0);
            }
            
            // Reset lastX and lastY to prevent connecting to the next stroke
            lastX = null;
            lastY = null;
        }

        // Mouse events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Pointer events (includes touchpad pressure support)
        canvas.addEventListener('pointerdown', startDrawing);
        canvas.addEventListener('pointermove', draw);
        canvas.addEventListener('pointerup', stopDrawing);
        canvas.addEventListener('pointerout', stopDrawing);

        // Touch events (for mobile/tablet with force touch)
        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);

        // Controls
        document.getElementById('brushSize').addEventListener('input', () => { /* Live update via drawPixel */ });
        document.getElementById('brushOpacity').addEventListener('input', () => { /* Live */ });
        document.getElementById('brushHardness').addEventListener('input', () => { /* Live */ });
        document.getElementById('brushType').addEventListener('change', () => { /* Live */ });

        document.getElementById('enableDual').addEventListener('click', (e) => {
            dualBrushEnabled = !dualBrushEnabled;
            e.target.textContent = dualBrushEnabled ? 'Disable Dual Brush' : 'Enable Dual Brush';
            // Customize secondary brush via prompt for simplicity
            if (dualBrushEnabled) {
                secondaryBrush.color = prompt('Secondary color (hex)?', '#ffffff') || '#ffffff';
            }
        });

        document.getElementById('clearCanvas').addEventListener('click', () => {
            frames[currentFrameIndex] = createWhiteFrame();
            switchFrame(currentFrameIndex); // Refresh view with onion skin
        });

        document.getElementById('eyedropper').addEventListener('click', () => {
            eyedropperMode = !eyedropperMode;
            if (eyedropperMode) {
                canvas.style.cursor = 'crosshair';
                document.getElementById('eyedropper').textContent = 'ðŸŽ¨ Eyedropper (Active)';
            } else {
                canvas.style.cursor = 'crosshair';
                document.getElementById('eyedropper').textContent = 'ðŸŽ¨ Eyedropper';
            }
        });

        document.getElementById('export').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'timelapse-drawing.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        // Animation
        document.getElementById('addFrame').addEventListener('click', () => {
            // Save current frame first (without onion skin)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const currentCanvas = document.createElement('canvas');
            currentCanvas.width = canvas.width;
            currentCanvas.height = canvas.height;
            const currentCtx = currentCanvas.getContext('2d');
            currentCtx.putImageData(frames[currentFrameIndex], 0, 0);
            ctx.drawImage(currentCanvas, 0, 0);
            frames[currentFrameIndex] = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Create a new white frame
            const whiteFrame = createWhiteFrame();
            frames.push(whiteFrame);
            
            // Switch to the new white frame
            switchFrame(frames.length - 1);
        });

        document.getElementById('frameSlider').addEventListener('input', (e) => {
            switchFrame(parseInt(e.target.value) - 1);
        });

        document.getElementById('playAnimation').addEventListener('click', () => {
            if (isPlaying) {
                clearInterval(animationInterval);
                isPlaying = false;
                document.getElementById('playAnimation').textContent = 'Play';
                return;
            }
            isPlaying = true;
            document.getElementById('playAnimation').textContent = 'Stop';
            animationInterval = setInterval(() => {
                currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                switchFrame(currentFrameIndex);
            }, 100); // 10 FPS for smoother animation
        });

        document.getElementById('toggleOnion').addEventListener('click', (e) => {
            onionSkin = !onionSkin;
            e.target.textContent = onionSkin ? 'Disable Onion Skin' : 'Enable Onion Skin';
            switchFrame(currentFrameIndex); // Refresh view
        });

        document.getElementById('exportGif').addEventListener('click', () => {
            const button = document.getElementById('exportGif');
            button.disabled = true;
            button.textContent = 'Generating GIF...';
            
            // Convert frames to image array
            const images = [];
            for (let i = 0; i < frames.length; i++) {
                // Create a temporary canvas for each frame
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(frames[i], 0, 0);
                images.push(tempCanvas.toDataURL('image/png'));
            }
            
            // Create GIF using gifshot
            gifshot.createGIF({
                images: images,
                gifWidth: canvas.width,
                gifHeight: canvas.height,
                interval: 0.1, // 0.1 seconds = 100ms between frames
                numFrames: frames.length,
                frameDuration: 2, // 2 = ~100ms per frame (10 FPS)
                sampleInterval: 10,
                numWorkers: 2
            }, (obj) => {
                if (!obj.error) {
                    const link = document.createElement('a');
                    link.download = 'animation.gif';
                    link.href = obj.image;
                    link.click();
                    
                    button.disabled = false;
                    button.textContent = 'Export GIF';
                } else {
                    alert('Error creating GIF: ' + obj.error);
                    button.disabled = false;
                    button.textContent = 'Export GIF';
                }
            });
        });

        // Timelapse Challenge handlers
        document.getElementById('startTimelapse').addEventListener('click', () => {
            if (confirm('Start Timelapse Challenge? You will have 30 strokes to create your artwork, and each stroke will be captured for a timelapse GIF.')) {
                // Reset state
                timelapseMode = true;
                strokesRemaining = 30;
                timelapseSnapshots = [];
                drawingBlocked = false;
                
                // Clear canvas
                frames[currentFrameIndex] = createWhiteFrame();
                switchFrame(currentFrameIndex);
                
                // Show challenge UI
                document.getElementById('timelapseChallenge').style.display = 'block';
                document.getElementById('strokeCount').textContent = '30';
                document.getElementById('exportTimelapse').disabled = true;
                document.getElementById('startTimelapse').textContent = 'Reset Challenge';
            }
        });

        document.getElementById('exportTimelapse').addEventListener('click', () => {
            const button = document.getElementById('exportTimelapse');
            button.disabled = true;
            button.textContent = 'Generating Timelapse...';
            
            // Create GIF from snapshots
            gifshot.createGIF({
                images: timelapseSnapshots,
                gifWidth: canvas.width,
                gifHeight: canvas.height,
                interval: 0.15, // 150ms per frame for timelapse
                numFrames: timelapseSnapshots.length,
                frameDuration: 3, // ~150ms per frame
                sampleInterval: 10,
                numWorkers: 2
            }, (obj) => {
                if (!obj.error) {
                    const link = document.createElement('a');
                    link.download = 'timelapse.gif';
                    link.href = obj.image;
                    link.click();
                    
                    button.disabled = false;
                    button.textContent = 'Export Timelapse';
                } else {
                    alert('Error creating timelapse: ' + obj.error);
                    button.disabled = false;
                    button.textContent = 'Export Timelapse';
                }
            });
        });

        // Helper to convert RGB to hex
        function rgbToHex(rgb) {
            const match = rgb.match(/\d+/g);
            if (!match) return rgb;
            const r = parseInt(match[0]);
            const g = parseInt(match[1]);
            const b = parseInt(match[2]);
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // Initialize color palette
        function initColorPalette() {
            const paletteContainer = document.getElementById('colorPalette');
            colorPalette.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.title = color;
                if (index === 10) swatch.classList.add('selected'); // Default olive green selected
                
                swatch.addEventListener('click', () => {
                    // Remove previous selection
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                    
                    // Update brush color
                    primaryBrush.color = color;
                });
                
                paletteContainer.appendChild(swatch);
            });
        }

        // Initialize
        initColorPalette();
        updateFrameDisplay();
        switchFrame(0);
        document.getElementById('toggleOnion').textContent = onionSkin ? 'Disable Onion Skin' : 'Enable Onion Skin';
    </script>
</body>
</html>